<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>é‡æ’é“¾è¡¨</title>
    <link href="/2020/03/17/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/03/17/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>é“¾è¡¨çš„æ’å…¥æ’åº</title>
    <link href="/2020/03/17/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/03/17/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>æ’å…¥æ’åºå¦™å•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šï¼Œæˆ‘é€‰æ‹©å½’å¹¶æ’åº(é€ƒ)ã€‚</p><a id="more"></a><pre><code>&#x2F;** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; *&#x2F;class Solution {public:    ListNode* insertionSortList(ListNode* head) {       ListNode* dummy&#x3D;new ListNode(0);       ListNode* prev;       dummy-&gt;next&#x3D;head;       while(head&amp;&amp;head-&gt;next){           if(head-&gt;val&lt;&#x3D;head-&gt;next-&gt;val){               head&#x3D;head-&gt;next;               continue;           }           prev&#x3D;dummy;           while(prev-&gt;next-&gt;val&lt;head-&gt;next-&gt;val){               prev&#x3D;prev-&gt;next;           }           ListNode* curr&#x3D;head-&gt;next;           head-&gt;next&#x3D;curr-&gt;next;           curr-&gt;next&#x3D;prev-&gt;next;           prev-&gt;next&#x3D;curr;       }       return dummy-&gt;next;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linked List</tag>
      
      <tag>Sorting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRUè®¾è®¡</title>
    <link href="/2020/03/17/LRU%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/03/17/LRU%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>LRU Cache</p><a id="more"></a><blockquote><p>è¿ç”¨ä½ æ‰€æŒæ¡çš„æ•°æ®ç»“æ„ï¼Œè®¾è®¡å’Œå®ç°ä¸€ä¸ª  LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜æœºåˆ¶ã€‚å®ƒåº”è¯¥æ”¯æŒä»¥ä¸‹æ“ä½œï¼š è·å–æ•°æ® get å’Œ å†™å…¥æ•°æ® put ã€‚</p><p>è·å–æ•°æ® get(key) - å¦‚æœå¯†é’¥ (key) å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è·å–å¯†é’¥çš„å€¼ï¼ˆæ€»æ˜¯æ­£æ•°ï¼‰ï¼Œå¦åˆ™è¿”å› -1ã€‚<br>å†™å…¥æ•°æ® put(key, value) - å¦‚æœå¯†é’¥ä¸å­˜åœ¨ï¼Œåˆ™å†™å…¥å…¶æ•°æ®å€¼ã€‚å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œå®ƒåº”è¯¥åœ¨å†™å…¥æ–°æ•°æ®ä¹‹å‰åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®å€¼ï¼Œä»è€Œä¸ºæ–°çš„æ•°æ®å€¼ç•™å‡ºç©ºé—´ã€‚</p><p>è¿›é˜¶:</p><p>ä½ æ˜¯å¦å¯ä»¥åœ¨ O(1) æ—¶é—´å¤æ‚åº¦å†…å®Œæˆè¿™ä¸¤ç§æ“ä½œï¼Ÿ</p><p>ç¤ºä¾‹:</p><p>LRUCache cache = new LRUCache( 2 /* ç¼“å­˜å®¹é‡ */ );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // è¿”å›  1<br>cache.put(3, 3);    // è¯¥æ“ä½œä¼šä½¿å¾—å¯†é’¥ 2 ä½œåºŸ<br>cache.get(2);       // è¿”å› -1 (æœªæ‰¾åˆ°)<br>cache.put(4, 4);    // è¯¥æ“ä½œä¼šä½¿å¾—å¯†é’¥ 1 ä½œåºŸ<br>cache.get(1);       // è¿”å› -1 (æœªæ‰¾åˆ°)<br>cache.get(3);       // è¿”å›  3<br>cache.get(4);       // è¿”å›  4</p><p>æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰-146</p></blockquote><p>hash table+ listçš„ç»“æ„<br>é¦–å…ˆè¦åœ¨O(1)çš„æ—¶é—´æŸ¥æ‰¾ï¼Œæœ€ç›´æ¥çš„å°±æ˜¯hash<br>æ¥ä¸‹æ¥è¿˜éœ€è¦O(1)çš„æ—¶é—´è¿›è¡ŒåŠ¨æ€æ“ä½œï¼Œå°±éœ€è¦ç”¨åˆ°Listçš„ç»“æ„<br>ç»¼åˆèµ·æ¥å°±æ˜¯ä¸€ä¸ªç±»ä¼¼æœ‰åºå­—å…¸çš„æ•°æ®ç»“æ„ã€‚<br>é€šè¿‡ç»´æŠ¤åˆ—è¡¨çš„é•¿åº¦ä»£è¡¨ç¼“å­˜å®¹é‡ï¼Œæ¡¶ç»“æ„ä¸­å­˜æ”¾æŒ‡å‘åˆ—è¡¨çš„è¿­ä»£å™¨(æŒ‡é’ˆ)<br>åŒæ—¶æ¯æ¬¡getæ“ä½œéƒ½è¦ç›¸åº”çš„æ›´æ–°è¡¨é¦–ä½ç½®ï¼Œæ›´æ–°çŠ¶æ€ã€‚æ­¤æ—¶ä½äºè¡¨æœ«çš„å…ƒç´ å°±ä¸€å®šæ˜¯æœ€ä¹…æ²¡æœ‰è®¿é—®çš„å…ƒç´ ï¼Œä»è€Œå°†å…¶å¼¹å‡ºï¼Œå†æ’å…¥æ–°å…ƒç´ ã€‚</p><pre><code>class LRUCache {public:    LRUCache(int capacity):cap(capacity) {    }        int get(int key) {        auto it&#x3D;m.find(key);        if(it&#x3D;&#x3D;m.end())            return -1;        int val&#x3D;it-&gt;second-&gt;second;        _list.erase(it-&gt;second);        _list.push_front(make_pair(key,val));        m[key]&#x3D;_list.begin();        return it-&gt;second-&gt;second;    }    void put(int key, int value) {        auto it&#x3D;m.find(key);        if(it!&#x3D;m.end()){            _list.erase(it-&gt;second);        }        _list.push_front(make_pair(key,value));        m[key]&#x3D;_list.begin();        if(_list.size()&gt;cap){            int key&#x3D;_list.back().first;            m.erase(key);            _list.pop_back();        }    }private:    unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; m;    list&lt;pair&lt;int,int&gt;&gt; _list;    int cap;};&#x2F;** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj &#x3D; new LRUCache(capacity); * int param_1 &#x3D; obj-&gt;get(key); * obj-&gt;put(key,value); *&#x2F; </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Hashing</tag>
      
      <tag>Designing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>æ ˆå®ç°é˜Ÿåˆ—</title>
    <link href="/2020/03/17/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2020/03/17/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<pre><code>å‡è±¡ã€‚</code></pre><a id="more"></a><p>ä¸€ä¸ªæ ˆå°±æ˜¯æ™®é€šçš„æ ˆï¼Œå†ç”¨ä¸€ä¸ªæ ˆè½¬ç§»å…ƒç´ ç”¨<br>å½“æœ‰å…ƒç´ å…¥é˜Ÿäº†ï¼Œå‹å…¥æ™®é€šçš„æ ˆï¼›<br>å½“æœ‰å…ƒç´ å‡ºé˜Ÿäº†ï¼Œå…ˆæŠŠæ ˆä¸Šé™¤æ ˆåº•ä»¥å¤–çš„å…¨éƒ¨è½¬ç§»ï¼ŒæŠŠæ ˆåº•å…ƒç´ è¿”å›å¹¶å¼¹å‡º<br>æ­¤åå¦‚æœå†å‡ºé˜Ÿï¼Œæ­¤æ—¶ç»åˆšåˆšçš„æ“ä½œï¼Œå¦ä¸€ä¸ªæ ˆä¸­å…ƒç´ é¡ºåºå‘ç”Ÿçš„å¥‡å¦™çš„è½¬å˜ï¼Œç›´æ¥è°ƒç”¨popå°±æ˜¯é˜Ÿåˆ—é¡ºåºçš„å‡ºé˜Ÿï¼Œç›´åˆ°å¦ä¸€ä¸ªæ ˆç©ºã€‚<br>peekå°±æ˜¯popæ²¡æœ‰popçš„æ“ä½œğŸ˜‚ğŸ˜‚ğŸ˜‚</p><pre><code>class MyQueue {public:    &#x2F;** Initialize your data structure here. *&#x2F;    MyQueue() {    }        &#x2F;** Push element x to the back of queue. *&#x2F;    void push(int x) {        front.push(x);    }        &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;    int pop() {        if(rear.empty()){            while(!front.empty()){                rear.push(front.top());                front.pop();            }        }        int temp&#x3D;rear.top();        rear.pop();        return temp;    }        &#x2F;** Get the front element. *&#x2F;    int peek() {        if(rear.empty()){            while(!front.empty()){                rear.push(front.top());                front.pop();                            }        }        return rear.top();    }        &#x2F;** Returns whether the queue is empty. *&#x2F;    bool empty() {        return front.empty()&amp;&amp;rear.empty();    }private:    stack&lt;int&gt; front;    stack&lt;int&gt; rear;};&#x2F;** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj &#x3D; new MyQueue(); * obj-&gt;push(x); * int param_2 &#x3D; obj-&gt;pop(); * int param_3 &#x3D; obj-&gt;peek(); * bool param_4 &#x3D; obj-&gt;empty(); *&#x2F;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>å­—ç¬¦ä¸²å‹ç¼©</title>
    <link href="/2020/03/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
    <url>/2020/03/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<p>æ¯”è¾ƒç®€å•çš„æ¯æ—¥ä¸€é¢˜~</p><a id="more"></a><p>æ•°å§ï¼Œæ²¡æƒ³åˆ°ä»€ä¹ˆå¥½åŠæ³•QAQ</p><pre><code>class Solution {public:    string compressString(string S) {        int len&#x3D;S.length();        string str;        for(int i&#x3D;0;i&lt;len;i++){            str+&#x3D;S[i];            int count&#x3D;1;            while(S[i]&#x3D;&#x3D;S[i+1]&amp;&amp;i&lt;len-1){                i++;                count++;            }            str+&#x3D;to_string(count);        }        int len1&#x3D;str.length();        if(len1&gt;&#x3D;len){            return S;        }        else            return str;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>æ‹¼å†™å•è¯</title>
    <link href="/2020/03/17/%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/"/>
    <url>/2020/03/17/%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p>Brute Forceâ€¦</p><a id="more"></a><p>ç›´æ¥æ•£åˆ—è¡¨ï¼Œå¿«ä¹++<br>ï¼ˆå…¶å®è¿™é‡Œåªæœ‰26ä¸ªå­—æ¯ï¼ŒDarkä¸å¿…å“ˆå¸Œï¼Œåªè¦ç»´æŠ¤ä¸€ä¸ªæ•°ç»„ğŸ˜‚<br>å½“ç„¶å†…å­˜å¾ˆçˆ†ç‚¸å•¦ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚</p><pre><code>class Solution {public:    int countCharacters(vector&lt;string&gt;&amp; words, string chars) {        int res&#x3D;0;        unordered_map&lt;char,int&gt; table;        for(char c:chars){            table[c]++;        }        unordered_map&lt;char,int&gt; temp&#x3D;table;        for(string s:words){            int count&#x3D;0;            for(char d:s){                if(temp.find(d)!&#x3D;temp.end()&amp;&amp;temp[d]&gt;0){                    count++;                    temp[d]--;                    continue;                }                else{                    count&#x3D;0;                    break;                                    }            }            temp&#x3D;table;            res+&#x3D;count;        }        return res;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Hashing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>å²›å±¿æœ€å¤§é¢ç§¯</title>
    <link href="/2020/03/15/%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <url>/2020/03/15/%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<p>å²›å±¿ç³»åˆ—No.2<br>  <a id="more"></a></p><pre><code>class Solution {    int dx[4]&#x3D;{1,-1,0,0};    int dy[4]&#x3D;{0,0,1,-1};public:    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        int row&#x3D;grid.size();        int col&#x3D;grid[0].size();        int res&#x3D;0;        deque&lt;pair&lt;int,int&gt;&gt; nodes;        for(int i&#x3D;0;i&lt;row;i++){            for(int j&#x3D;0;j&lt;col;j++){                int area&#x3D;0;                nodes.push_back(make_pair(i,j));                while(!nodes.empty()){                    int x&#x3D;nodes.front().first;                    int y&#x3D;nodes.front().second;                    nodes.pop_front();                    if(!ingrid(x,y,row,col)||grid[x][y]&#x3D;&#x3D;0)    continue;                    area++;                    grid[x][y]&#x3D;0;                    for(int k&#x3D;0;k&lt;4;k++){                        nodes.push_back(make_pair(x+dx[k],y+dy[k]));                    }                }                res&#x3D;max(res,area);            }        }        return res;    }    bool ingrid(int i,int j,int row,int col){        return (i&gt;&#x3D;0&amp;&amp;i&lt;row)&amp;&amp;(j&gt;&#x3D;0&amp;&amp;j&lt;col);    }};</code></pre><p>å½“ç„¶ï¼Œå…¶å®DFSæ›´ç®€å•ç›´è§‚çš„è¯´ï¼Œå¯ä»¥ç›´æ¥DFSå‡½æ•°ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ç”¨æ ˆæ¨¡æ‹ŸDFSã€‚ æŠŠ4ä¸ªæ–¹å‘è¿›è¡Œæœç´¢ï¼Œé¢ç§¯å¢é•¿ï¼Œå²›å±¿æ¢ç´¢å®Œå°±ç½®0é¿å…åå¤æ¢ç´¢ï¼Œæœ€åè¿”å›é¢ç§¯ä¸­æœ€å¤§çš„å³å¯ã€‚<br>å…¶å®ï¼Œå¹¶æŸ¥é›†ä¹Ÿå¯ä»¥ã€‚æŠŠæ‰€æœ‰ä¸º1çš„è¿é€šåŸŸçš„å­èŠ‚ç‚¹æ•°è¿›è¡Œç»Ÿè®¡ï¼Œæ±‚æœ€å¤§å€¼ä¹Ÿå¯¹ã€‚</p><pre><code>class Solution {    int maxArea&#x3D;0;    vector&lt;int&gt; parent;    vector&lt;int&gt; size;public:            void UnionFind(int n){        parent&#x3D;vector&lt;int&gt;(n,-1);        size&#x3D;vector&lt;int&gt;(n,0);    }    int find(int p){        while(p!&#x3D;parent[p]){            parent[p]&#x3D;parent[parent[p]];            p&#x3D;parent[p];        }        return p;    }    bool connected(int p,int q){        int rootP&#x3D;find(p);        int rootQ&#x3D;find(q);        return rootP&#x3D;&#x3D;rootQ;        }       void Union(int p,int q){        int rootP&#x3D;find(p);            int rootQ&#x3D;find(q);            if(connected(p,q))    return;            if(size[rootP]&gt;size[rootQ]){                parent[rootQ]&#x3D;rootP;                size[rootP]+&#x3D;size[rootQ];                maxArea&#x3D;max(size[rootP],maxArea);            }            else{                parent[rootP]&#x3D;rootQ;                size[rootQ]+&#x3D;size[rootP];                maxArea&#x3D;max(size[rootQ],maxArea);            }        }         inline bool inGrid(int x,int y,int row,int col){        return (x&gt;&#x3D;0&amp;&amp;x&lt;row)&amp;&amp;(y&gt;&#x3D;0&amp;&amp;y&lt;col);    }    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        int row&#x3D;grid.size();        if(row&#x3D;&#x3D;0)            return 0;        int col&#x3D;grid[0].size();        UnionFind(row*col);        for(int m&#x3D;0;m&lt;row;m++){            for(int n&#x3D;0;n&lt;col;n++){                if(grid[m][n]&#x3D;&#x3D;1){                    parent[m*col+n]&#x3D;m*col+n;                    size[m*col+n]&#x3D;1;                }            }        }        bool iszero&#x3D;true;        for(int i&#x3D;0;i&lt;row;i++){            for(int j&#x3D;0;j&lt;col;j++){                if(grid[i][j]&#x3D;&#x3D;1){                    iszero&#x3D;false;                    maxArea&#x3D;max(maxArea,1);                    if(i&gt;0&amp;&amp;grid[i-1][j]&#x3D;&#x3D;1){                           Union(i*col+j,(i-1)*col+j);                    }                    if(j&gt;0&amp;&amp;grid[i][j-1]&#x3D;&#x3D;1){                        Union(i*col+j,i*col+j-1);                     }                 }            }        }        if(iszero){            return 0;        }        else            return maxArea;    }};</code></pre><p>æˆ‘ç»ˆäºå†™å‡ºæ¥äº†ï¼ï¼ï¼ï¼ï¼bugæ— æ•°çš„å¹¶èŒ¶å‡ å•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Š</p>]]></content>
    
    
    
    <tags>
      
      <tag>Breadth First Search</tag>
      
      <tag>Depth First Search</tag>
      
      <tag>Union Find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>æœ€å¤§å›¢é˜Ÿè¡¨ç°å€¼</title>
    <link href="/2020/03/15/%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%98%9F%E8%A1%A8%E7%8E%B0%E5%80%BC/"/>
    <url>/2020/03/15/%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%98%9F%E8%A1%A8%E7%8E%B0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p> ä¼˜å…ˆçº§é˜Ÿåˆ—æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘è¿˜æ²¡å­¦åˆ°â€¦ğŸ˜­<br> <a id="more"></a><br>å…¬å¸æœ‰ç¼–å·ä¸º 1 åˆ° n çš„ n ä¸ªå·¥ç¨‹å¸ˆï¼Œç»™ä½ ä¸¤ä¸ªæ•°ç»„ speed å’Œ efficiency ï¼Œå…¶ä¸­ speed[i] å’Œ efficiency[i] åˆ†åˆ«ä»£è¡¨ç¬¬ i ä½å·¥ç¨‹å¸ˆçš„é€Ÿåº¦å’Œæ•ˆç‡ã€‚è¯·ä½ è¿”å›ç”±æœ€å¤š k ä¸ªå·¥ç¨‹å¸ˆç»„æˆçš„ â€‹â€‹â€‹â€‹â€‹â€‹æœ€å¤§å›¢é˜Ÿè¡¨ç°å€¼ ï¼Œç”±äºç­”æ¡ˆå¯èƒ½å¾ˆå¤§ï¼Œè¯·ä½ è¿”å›ç»“æœå¯¹ 10^9 + 7 å–ä½™åçš„ç»“æœã€‚</p><p>å›¢é˜Ÿè¡¨ç°å€¼ çš„å®šä¹‰ä¸ºï¼šä¸€ä¸ªå›¢é˜Ÿä¸­ã€Œæ‰€æœ‰å·¥ç¨‹å¸ˆé€Ÿåº¦çš„å’Œã€ä¹˜ä»¥ä»–ä»¬ã€Œæ•ˆç‡å€¼ä¸­çš„æœ€å°å€¼ã€ã€‚</p><p>ç¤ºä¾‹ 1ï¼š</p><p>è¾“å…¥ï¼šn = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2<br>è¾“å‡ºï¼š60<br>è§£é‡Šï¼š<br>æˆ‘ä»¬é€‰æ‹©å·¥ç¨‹å¸ˆ 2ï¼ˆspeed=10 ä¸” efficiency=4ï¼‰å’Œå·¥ç¨‹å¸ˆ 5ï¼ˆspeed=5 ä¸” efficiency=7ï¼‰ã€‚ä»–ä»¬çš„å›¢é˜Ÿè¡¨ç°å€¼ä¸º performance = (10 + 5) * min(4, 7) = 60 ã€‚</p><p>ç¤ºä¾‹ 2ï¼š</p><p>è¾“å…¥ï¼šn = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3<br>è¾“å‡ºï¼š68<br>è§£é‡Šï¼š<br>æ­¤ç¤ºä¾‹ä¸ç¬¬ä¸€ä¸ªç¤ºä¾‹ç›¸åŒï¼Œé™¤äº† k = 3 ã€‚æˆ‘ä»¬å¯ä»¥é€‰æ‹©å·¥ç¨‹å¸ˆ 1 ï¼Œå·¥ç¨‹å¸ˆ 2 å’Œå·¥ç¨‹å¸ˆ 5 å¾—åˆ°æœ€å¤§çš„å›¢é˜Ÿè¡¨ç°å€¼ã€‚è¡¨ç°å€¼ä¸º performance = (2 + 10 + 5) * min(5, 4, 7) = 68 ã€‚</p><p>ç¤ºä¾‹ 3ï¼š</p><p>è¾“å…¥ï¼šn = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4<br>è¾“å‡ºï¼š72</p><p>æç¤ºï¼š</p><pre><code>1 &lt;= n &lt;= 10^5speed.length == nefficiency.length == n1 &lt;= speed[i] &lt;= 10^51 &lt;= efficiency[i] &lt;= 10^81 &lt;= k &lt;= n</code></pre><p>æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰</p><pre><code>class Solution {struct Engineer {int64_t s;int64_t e;Engineer(int64_t _s, int64_t _e) : s(_s), e(_e) {}bool operator &lt; (const Engineer &amp;r) const {return this-&gt;e &gt; r.e;}};vector&lt;Engineer&gt; data;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;public:int maxPerformance(int n, vector&lt;int&gt;&amp; speed, vector&lt;int&gt;&amp; efficiency, int k) {for(int i &#x3D; 0; i &lt; n; i++) {data.push_back(Engineer(speed[i], efficiency[i]));}sort(data.begin(), data.end());int64_t sum &#x3D; 0, anw &#x3D; 0;for(int i &#x3D; 0; i &lt; n; i++) {            sum +&#x3D; data[i].s;pq.push(data[i].s);if(pq.size() &gt; size_t(k)) {int64_t tmp &#x3D; pq.top();pq.pop();sum -&#x3D; tmp;}anw &#x3D; max(anw, sum * data[i].e);}return anw%(1000000007);}};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Priority Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>_200_å²›å±¿æ•°é‡</title>
    <link href="/2020/03/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <url>/2020/03/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>è¯•è¯•çœ‹å¹¶æŸ¥é›†çš„æ–¹æ³•ï¼š</p><a id="more"></a><h3 id="å™”-å™”-å’š"><a href="#å™”-å™”-å’š" class="headerlink" title="å™”  å™”  å’š"></a>å™”  å™”  å’š</h3><pre><code>class UnionFind{    private:        int Count;        vector&lt;int&gt; parent;        vector&lt;int&gt; size;    public:        UnionFind(int n){            this-&gt;Count&#x3D;n;            for(int i&#x3D;0;i&lt;n;i++){                parent.push_back(i);                size.push_back(1);            }        }        int find(int p){            while(p!&#x3D;parent[p]){                parent[p]&#x3D;parent[parent[p]];                p&#x3D;parent[p];            }            return p;        }        void Union(int p,int q){            int rootP&#x3D;find(p);            int rootQ&#x3D;find(q);            if(connected(p,q))    return;            if(size[rootP]&gt;size[rootQ]){                parent[rootQ]&#x3D;rootP;                size[rootP]+&#x3D;size[rootQ];            }            else{                parent[rootP]&#x3D;rootQ;                size[rootQ]+&#x3D;size[rootP];            }            Count--;        }        bool connected(int p,int q){            int rootP&#x3D;find(p);            int rootQ&#x3D;find(q);            return rootP&#x3D;&#x3D;rootQ;        }        int count(){return Count;}};class Solution {public:    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {        int row&#x3D;grid.size();        if(row&#x3D;&#x3D;0)            return 0;        int col&#x3D;grid[0].size();        if(col&#x3D;&#x3D;0)            return 0;        int n&#x3D;row*col;        UnionFind AA(n+1);        int dx[2]&#x3D;{1,0};        int dy[2]&#x3D;{0,-1};        for(int i&#x3D;0;i&lt;n;i++){            int x&#x3D;i&#x2F;col;            int y&#x3D;i%col;            if(grid[x][y]&#x3D;&#x3D;&#39;1&#39;){                for(int j&#x3D;0;j&lt;2;j++){                    int xx&#x3D;x+dx[j];                    int yy&#x3D;y+dy[j];                    if(xx&gt;&#x3D;0&amp;&amp;xx&lt;row&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;col&amp;&amp;grid[xx][yy]&#x3D;&#x3D;&#39;1&#39;){                        AA.Union(i,yy+xx*col);                    }                }            }            else{                AA.Union(i,n);            }        }        return AA.count()-1;            }};</code></pre><p>è¿˜æœ‰DFSå’ŒBFSçš„æ–¹æ³•&gt;&gt;&gt;&gt;&gt;&gt;</p>]]></content>
    
    
    
    <tags>
      
      <tag>Breadth First Search</tag>
      
      <tag>Depth First Search</tag>
      
      <tag>Union Find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>æœ€é•¿ä¸Šå‡å­åºåˆ—</title>
    <link href="/2020/03/14/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2020/03/14/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>éš¾ä»¥ç½®ä¿¡çš„äºŒåˆ†æ³•</p><a id="more"></a><blockquote><p>ç»™å®šä¸€ä¸ªæ— åºçš„æ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ã€‚</p><p>ç¤ºä¾‹:</p><p>è¾“å…¥: [10,9,2,5,3,7,101,18]<br>è¾“å‡º: 4<br>è§£é‡Š: æœ€é•¿çš„ä¸Šå‡å­åºåˆ—æ˜¯ [2,3,7,101]ï¼Œå®ƒçš„é•¿åº¦æ˜¯ 4ã€‚</p><p>è¯´æ˜:</p><pre><code>å¯èƒ½ä¼šæœ‰å¤šç§æœ€é•¿ä¸Šå‡å­åºåˆ—çš„ç»„åˆï¼Œä½ åªéœ€è¦è¾“å‡ºå¯¹åº”çš„é•¿åº¦å³å¯ã€‚ä½ ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦åº”è¯¥ä¸º O(n2) ã€‚</code></pre><p>è¿›é˜¶: ä½ èƒ½å°†ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦é™ä½åˆ° O(n log n) å—?</p><p>æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰æ¯æ—¥ä¸€é¢˜Day14</p></blockquote><h3 id="åæ­£æˆ‘æ˜¯åªä¼šDPçš„æ¸£ğŸ˜‚"><a href="#åæ­£æˆ‘æ˜¯åªä¼šDPçš„æ¸£ğŸ˜‚" class="headerlink" title="åæ­£æˆ‘æ˜¯åªä¼šDPçš„æ¸£ğŸ˜‚"></a>åæ­£æˆ‘æ˜¯åªä¼šDPçš„æ¸£ğŸ˜‚</h3><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {          int n&#x3D;nums.size();        if(n&lt;1)            return 0;        int dp[n]&#x3D;{1};        int m&#x3D;0;        for(int num:nums){            int lo&#x3D;0;            int hi&#x3D;m;            while(lo&lt;hi){                int mid&#x3D;lo+(hi-lo)&#x2F;2;                if(dp[mid]&lt;num)                    lo&#x3D;mid+1;                else                    hi&#x3D;mid;            }            dp[lo]&#x3D;num;            if(lo&#x3D;&#x3D;m)                m++;        }        return m;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>æ‰“å¼€è½¬ç›˜é”</title>
    <link href="/2020/03/14/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/"/>
    <url>/2020/03/14/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ä½ æœ‰ä¸€ä¸ªå¸¦æœ‰å››ä¸ªåœ†å½¢æ‹¨è½®çš„è½¬ç›˜é”ã€‚æ¯ä¸ªæ‹¨è½®éƒ½æœ‰10ä¸ªæ•°å­—ï¼š â€˜0â€™, â€˜1â€™, â€˜2â€™, â€˜3â€™, â€˜4â€™, â€˜5â€™, â€˜6â€™, â€˜7â€™, â€˜8â€™, â€˜9â€™ ã€‚æ¯ä¸ªæ‹¨è½®å¯ä»¥è‡ªç”±æ—‹è½¬ï¼šä¾‹å¦‚æŠŠ â€˜9â€™ å˜ä¸º  â€˜0â€™ï¼Œâ€™0â€™ å˜ä¸º â€˜9â€™ ã€‚æ¯æ¬¡æ—‹è½¬éƒ½åªèƒ½æ—‹è½¬ä¸€ä¸ªæ‹¨è½®çš„ä¸€ä½æ•°å­—ã€‚</p><p>é”çš„åˆå§‹æ•°å­—ä¸º â€˜0000â€™ ï¼Œä¸€ä¸ªä»£è¡¨å››ä¸ªæ‹¨è½®çš„æ•°å­—çš„å­—ç¬¦ä¸²ã€‚</p><p>åˆ—è¡¨ deadends åŒ…å«äº†ä¸€ç»„æ­»äº¡æ•°å­—ï¼Œä¸€æ—¦æ‹¨è½®çš„æ•°å­—å’Œåˆ—è¡¨é‡Œçš„ä»»ä½•ä¸€ä¸ªå…ƒç´ ç›¸åŒï¼Œè¿™ä¸ªé”å°†ä¼šè¢«æ°¸ä¹…é”å®šï¼Œæ— æ³•å†è¢«æ—‹è½¬ã€‚</p><p>å­—ç¬¦ä¸² target ä»£è¡¨å¯ä»¥è§£é”çš„æ•°å­—ï¼Œä½ éœ€è¦ç»™å‡ºæœ€å°çš„æ—‹è½¬æ¬¡æ•°ï¼Œå¦‚æœæ— è®ºå¦‚ä½•ä¸èƒ½è§£é”ï¼Œè¿”å› -1ã€‚</p><p>ç¤ºä¾‹ 1:</p><p>è¾“å…¥ï¼šdeadends = [â€œ0201â€,â€0101â€,â€0102â€,â€1212â€,â€2002â€], target = â€œ0202â€<br>è¾“å‡ºï¼š6<br>è§£é‡Šï¼š<br>å¯èƒ½çš„ç§»åŠ¨åºåˆ—ä¸º â€œ0000â€ -&gt; â€œ1000â€ -&gt; â€œ1100â€ -&gt; â€œ1200â€ -&gt; â€œ1201â€ -&gt; â€œ1202â€ -&gt; â€œ0202â€ã€‚<br>æ³¨æ„ â€œ0000â€ -&gt; â€œ0001â€ -&gt; â€œ0002â€ -&gt; â€œ0102â€ -&gt; â€œ0202â€ è¿™æ ·çš„åºåˆ—æ˜¯ä¸èƒ½è§£é”çš„ï¼Œ<br>å› ä¸ºå½“æ‹¨åŠ¨åˆ° â€œ0102â€ æ—¶è¿™ä¸ªé”å°±ä¼šè¢«é”å®šã€‚</p><p>ç¤ºä¾‹ 2:</p><p>è¾“å…¥: deadends = [â€œ8888â€], target = â€œ0009â€<br>è¾“å‡ºï¼š1<br>è§£é‡Šï¼š<br>æŠŠæœ€åä¸€ä½åå‘æ—‹è½¬ä¸€æ¬¡å³å¯ â€œ0000â€ -&gt; â€œ0009â€ã€‚</p><p>ç¤ºä¾‹ 3:</p><p>è¾“å…¥: deadends = [â€œ8887â€,â€8889â€,â€8878â€,â€8898â€,â€8788â€,â€8988â€,â€7888â€,â€9888â€], target = â€œ8888â€<br>è¾“å‡ºï¼š-1<br>è§£é‡Šï¼š<br>æ— æ³•æ—‹è½¬åˆ°ç›®æ ‡æ•°å­—ä¸”ä¸è¢«é”å®šã€‚</p><p>ç¤ºä¾‹ 4:</p><p>è¾“å…¥: deadends = [â€œ0000â€], target = â€œ8888â€<br>è¾“å‡ºï¼š-1</p><p>æç¤ºï¼š</p><pre><code>æ­»äº¡åˆ—è¡¨ deadends çš„é•¿åº¦èŒƒå›´ä¸º [1, 500]ã€‚ç›®æ ‡æ•°å­— target ä¸ä¼šåœ¨ deadends ä¹‹ä¸­ã€‚æ¯ä¸ª deadends å’Œ target ä¸­çš„å­—ç¬¦ä¸²çš„æ•°å­—ä¼šåœ¨ 10,000 ä¸ªå¯èƒ½çš„æƒ…å†µ &apos;0000&apos; åˆ° &apos;9999&apos; ä¸­äº§ç”Ÿã€‚</code></pre><p>æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰752</p></blockquote><pre><code>class Solution {public:    int openLock(vector&lt;string&gt;&amp; deadends, string target) {        unordered_set&lt;string&gt; deadset(deadends.begin(),deadends.end());        if(deadset.find(&quot;0000&quot;)!&#x3D;deadset.end())            return -1;        unordered_set&lt;string&gt; visited;        deque&lt;string&gt; temp;        visited.insert(&quot;0000&quot;);        temp.push_back(&quot;0000&quot;);        int step&#x3D;0;        while(!temp.empty()){            int n&#x3D;temp.size();            for(int j&#x3D;0;j&lt;n;j++){                string s&#x3D;temp.front();                temp.pop_front();                if(s&#x3D;&#x3D;target)                    return step;                                for(int i&#x3D;0;i&lt;4;i++){                    string s1,s2;                    s1&#x3D;s;s2&#x3D;s;                    s1[i]&#x3D;(s1[i]&#x3D;&#x3D;&#39;0&#39;)?&#39;9&#39;:s1[i]-1;                    s2[i]&#x3D;(s2[i]&#x3D;&#x3D;&#39;9&#39;)?&#39;0&#39;:s2[i]+1;                    if(visited.find(s1)&#x3D;&#x3D;visited.end()&amp;&amp;deadset.find(s1)&#x3D;&#x3D;deadset.end()){                        temp.push_back(s1);                        visited.insert(s1);                    }                    if(visited.find(s2)&#x3D;&#x3D;visited.end()&amp;&amp;deadset.find(s2)&#x3D;&#x3D;deadset.end()){                        temp.push_back(s2);                        visited.insert(s2);                    }                }            }            step++;        }        return -1;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Breadth First Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>å¤åŸIPåœ°å€</title>
    <link href="/2020/03/14/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <url>/2020/03/14/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p> æ­¤é¢˜è¾¹ç•Œæ¡ä»¶æœ‰å¾ˆå¤šç»†èŠ‚<br> <a id="more"></a></p><blockquote><p>IPåœ°å€çš„èŒƒå›´æ˜¯0~255ï¼Œè¿™ä¸ª0çš„å­˜åœ¨å°±å¾ˆemm<br>æ¯”å¦‚ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹&gt;â€010010â€<br>0è¿™é‡Œæ˜¯ä¸å¯ä»¥å‰ç½®äºä¸€ä¸ªæ•´æ•°å‰çš„!010ï¼Œ001è¿™ç§æ˜¯ä¸å…è®¸çš„</p></blockquote><blockquote><p>æ ‡å‡†å›æº¯æ³•ï¼š<br>    ä»ä¸€ä¸ªèµ·ç‚¹å¼€å§‹ï¼Œå‘å¯è¡Œçš„æ‰€æœ‰åˆ†æ”¯ä¸­å°è¯•ï¼Œå¹¶å°†å¯è¡Œçš„åŠ å…¥è§£é›†ï¼Œå¦‚æœå‘ç°ä¸ç¬¦åˆï¼Œç«‹åˆ»åˆ é™¤å›åˆ°ä¸Šä¸€æ­¥é‡æ–°é€‰æ‹©ã€‚<br>    è¿™é‡Œçš„pruningæ¡ä»¶æ˜¯å½“å‰çš„IPå–å®Œåï¼Œåé¢å‰©ä½™çš„å­—ç¬¦ä¸²é•¿åº¦æ˜¯å¦å¯ä»¥æ”¯æŒåç»­çš„IPåœ°å€é€‰å–ã€‚<br>    depthä»£è¡¨ä½ å–äº†å‡ ä¸ªIPåœ°å€ï¼Œä¾‹å¦‚depth=2ï¼Œå‰©ä½™å­—ç¬¦ä¸²é•¿åº¦å´æœ‰7ï¼Œæ­¤æ—¶å°±å‘ç”Ÿäº†ä¸Šæº¢ï¼Œå› æ­¤éœ€è¦è·³è¿‡è¿™ç§æƒ…å†µï¼Œå°±æœ‰äº†<br>        s.length()-1-right&gt;3<em>(4-depth) 3ä¸ºæ¯ä¸€ä½IPæœ€é•¿çš„å¯èƒ½æ•°å­—<br>    åŒç†ï¼Œä¸‹æº¢æ—¶ï¼Œä¼šæœ‰<br>        s.length()-1-right&lt;1</em>(4-depth)<br>    å¯¹äºç¬¦åˆæ¡ä»¶çš„å­ä¸²ï¼Œå°†å®ƒè½¬ä¸ºæ•°å­—ï¼Œåˆ¤æ–­æ˜¯å¦åˆæ³•(0-255)<br>    ç„¶åå†æ¥åœ¨ç»“æœä¸²çš„æœ«å°¾+â€.â€<br>    é€’å½’(æ·±åº¦æœç´¢)ï¼Œç›´åˆ°depth==4<br>    è¿˜æœ‰ä¸€ç‚¹å°±æ˜¯å¯¹å‰å¯¼0çš„åˆ¤æ–­ï¼Œå«æœ‰å‰å¯¼0çš„åˆ†æ”¯åº”ç«‹åˆ»åˆ å»ï¼</p></blockquote><pre><code>class Solution {public:    vector&lt;string&gt; restoreIpAddresses(string s) {        vector&lt;string&gt; res;        backtrack(0,1,res,s,&quot;&quot;);        return res;    }    void backtrack(int left,int depth,vector&lt;string&gt;&amp; res,string &amp;s,string temp){        if(left&gt;&#x3D;s.length())            return;        for(int right&#x3D;left;right&lt;s.length()&amp;&amp;right&lt;&#x3D;left+2;right++){            if(s.length()-right-1&gt;3*(4-depth))    continue;            if(s.length()-right-1&lt;1*(4-depth))    continue;            char t[4];            int i&#x3D;0;            for(;i&lt;&#x3D;right-left;i++){                t[i]&#x3D;s[left+i];            }            t[i]&#x3D;&#39;\0&#39;;            if(is_ip(t)){                if(depth&#x3D;&#x3D;4){                    temp+&#x3D;t;                    res.push_back(temp);                    return;                }                backtrack(right+1,depth+1,res,s,temp+t+&quot;.&quot;);            }        }    }    bool is_ip(const char s[]){        if(s[0]&#x3D;&#x3D;&#39;0&#39;&amp;&amp;s[1]!&#x3D;&#39;\0&#39;)            return false;        int a;        sscanf(s,&quot;%d&quot;,&amp;a);        if(a&gt;&#x3D;0&amp;&amp;a&lt;256)            return true;        else            return false;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Backtrack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CountCompleteTreeNodes</title>
    <link href="/2020/03/13/CountCompleteTreeNodes/"/>
    <url>/2020/03/13/CountCompleteTreeNodes/</url>
    
    <content type="html"><![CDATA[<pre><code>&#x2F;** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; *&#x2F;class Solution {public:    int countNodes(TreeNode* root) {        if(!root)            return 0;        int left&#x3D;level(root-&gt;left);        int right&#x3D;level(root-&gt;right);        if(left&#x3D;&#x3D;right){            return countNodes(root-&gt;right)+(1&lt;&lt;left);        }        else{            return countNodes(root-&gt;left)+(1&lt;&lt;right);        }    }    int level(TreeNode* root){        int level&#x3D;0;        while(root){            root&#x3D;root-&gt;left;            level++;        }        return level;    }};</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreePaths</title>
    <link href="/2020/03/13/BinaryTreePaths/"/>
    <url>/2020/03/13/BinaryTreePaths/</url>
    
    <content type="html"><![CDATA[<pre><code>&#x2F;** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; *&#x2F;class Solution {public:    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {        if(!root)            return {};        vector&lt;string&gt; res;        Path(root,res,&quot;&quot;);        return res;      }    void Path(TreeNode* root,vector&lt;string&gt;&amp; res,string path){        path+&#x3D;to_string(root-&gt;val);        if(!root-&gt;left&amp;&amp;!root-&gt;right){            res.push_back(path);            return;        }              if(root-&gt;left)            Path(root-&gt;left,res,path+&quot;-&gt;&quot;);        if(root-&gt;right)            Path(root-&gt;right,res,path+&quot;-&gt;&quot;);    }};</code></pre><p>ä¸é€’å½’è¿™å°±ç»å¯¹ä¸æ˜¯ç®€å•çš„é—®é¢˜äº†(è¯´åˆ°åº•è¿˜æ˜¯è‡ªå·±å¤ªvegetable)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MajorityElement</title>
    <link href="/2020/03/13/MajorityElement/"/>
    <url>/2020/03/13/MajorityElement/</url>
    
    <content type="html"><![CDATA[<pre><code>class Solution {public:    int majorityElement(vector&lt;int&gt;&amp; nums) {        int n&#x3D;nums.size();        int count&#x3D;0;        int temp&#x3D;0;        for(int i&#x3D;0;i&lt;n;i++){            if(count&#x3D;&#x3D;0){                temp&#x3D;nums[i];                count++;            }            else{                nums[i]&#x3D;&#x3D;temp?count++:count--;            }        }        return temp;    }};</code></pre><pre><code>class Solution {public:    int majorityElement(vector&lt;int&gt;&amp; nums) {        int n&#x3D;nums.size();        int res&#x3D;0;        for(int i&#x3D;0;i&lt;32;i++){            int one&#x3D;0,zero&#x3D;0;            for(int j&#x3D;0;j&lt;n;j++){                if(one&gt;n&#x2F;2||zero&gt;n&#x2F;2)   break;                if((nums[j]&amp;(1&lt;&lt;i))!&#x3D;0)   one++;                else   zero++;               }            if(one&gt;zero)                res&#x3D;res|(1&lt;&lt;i);        }        return res;    }};</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Reverse Nodes in k-Group</title>
    <link href="/2020/03/12/LC-25/"/>
    <url>/2020/03/12/LC-25/</url>
    
    <content type="html"><![CDATA[<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>Example:</p><p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>Note:</p><pre><code>Only constant extra memory is allowed.You may not alter the values in the list&#39;s nodes, only nodes itself may be changed.</code></pre><pre><code>&#x2F;** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; *&#x2F;class Solution {public:    ListNode* reverseKGroup(ListNode* head, int k) {        ListNode* dummy&#x3D;new ListNode(0);        ListNode* prev&#x3D;dummy;        dummy-&gt;next&#x3D;head;        ListNode* curr&#x3D;head;        ListNode* temp;        int len&#x3D;0;        while(head){            len++;            head&#x3D;head-&gt;next;        }        head&#x3D;dummy-&gt;next;        for(int i&#x3D;0;i&lt;len&#x2F;k;i++){            for(int j&#x3D;0;j&lt;k-1;j++){                temp&#x3D;curr-&gt;next;                curr-&gt;next&#x3D;temp-&gt;next;                temp-&gt;next&#x3D;prev-&gt;next;                prev-&gt;next&#x3D;temp;            }            prev&#x3D;curr;            curr&#x3D;prev-&gt;next;        }        return dummy-&gt;next;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linked List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode1071</title>
    <link href="/2020/03/12/LeetCode1071/"/>
    <url>/2020/03/12/LeetCode1071/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/12/LeetCode1071/t.png" srcset="/img/loading.gif" alt="1071"></p><blockquote><p>greatest common divisor<br>æœ€å¤§å…¬å› æ•°ä¸è¾—è½¬ç›¸é™¤æ³•<br>    gcd(a,b)=gcd(b,a%b)<br>è¯æ˜ï¼šè®¾a=kb+r, r=a%b<br>    è®¾d=gcd(a,b), d|a,d|b;<br>    r=a-kb; r/d=a/d-k*b/d;<br>    æ‰€ä»¥r/dä¹Ÿæ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œd|r<br>    æ‰€ä»¥gcd(a,b)=gcd(b.a%b).<br>    åŒæ ·çš„ï¼Œå¯¹äºä¸€ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦è€Œè¨€ï¼Œå¯ä»¥å…ˆæ‰¾åˆ°å®ƒä»¬çš„å…¬å› æ•°é•¿åº¦çš„å­ä¸²ï¼Œå¦‚æœå­˜åœ¨è¿™æ ·ä¸€ä¸ªå­ä¸²ï¼Œé‚£ä¹ˆå®ƒçš„é•¿åº¦å¿…ç„¶ç­‰äºåŸå­—ç¬¦ä¸²ä¸­çš„ä»»ä¸€ä¸ªæœ€å°å› å­é•¿åº¦çš„å­å­—ç¬¦ä¸²ã€‚<br>    æ³¨æ„æ¯æ¬¡éƒ½è¦å…ˆè¿›è¡Œæ¡ä»¶åˆ¤æ–­ï¼Œå³å®ƒä»¬æ˜¯å¦åŒæ„</p></blockquote><pre><code>class Solution {public:    inline int gcd(int a,int b){return b&#x3D;&#x3D;0?a:gcd(b,a%b);}    string gcdOfStrings(string str1, string str2) {        if(str1+str2!&#x3D;str2+str1)    return&quot;&quot;;        return str1.substr(0,gcd(str1.size(),str2.size()));    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Combination</title>
    <link href="/2020/03/11/Combination/"/>
    <url>/2020/03/11/Combination/</url>
    
    <content type="html"><![CDATA[<h3 id="215-Combination-Sum-III"><a href="#215-Combination-Sum-III" class="headerlink" title="215.Combination Sum III"></a>215.Combination Sum III</h3><p>å…ˆä¸Šä»£ç 233ï¼š</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {        vector&lt;vector&lt;int&gt;&gt; res;        vector&lt;int&gt; path;        backtrack(n,path,k,res,0);        return res;    }    void backtrack(int n,vector&lt;int&gt;&amp; path,int k,vector&lt;vector&lt;int&gt;&gt;&amp; res,int start){        if(n&lt;0)            return;        if(k&#x3D;&#x3D;0){            if(n&#x3D;&#x3D;0)                res.push_back(path);            return;        }        for(int i&#x3D;start;i&lt;9;i++){            path.push_back(i+1);            backtrack(n-(i+1),path,k-1,res,i+1);            path.pop_back();        }    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Backtrack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>findKth</title>
    <link href="/2020/03/11/findKth/"/>
    <url>/2020/03/11/findKth/</url>
    
    <content type="html"><![CDATA[<h3 id="215-å¯»æ‰¾ç¬¬Kå¤§çš„å…ƒç´ "><a href="#215-å¯»æ‰¾ç¬¬Kå¤§çš„å…ƒç´ " class="headerlink" title="215.å¯»æ‰¾ç¬¬Kå¤§çš„å…ƒç´ "></a>215.å¯»æ‰¾ç¬¬Kå¤§çš„å…ƒç´ </h3><p><img src="/2020/03/11/findKth/find.png" srcset="/img/loading.gif" alt="txt"></p><pre><code>class Solution {public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {        int n&#x3D;nums.size();        return findKth(nums,0,n-1,k);    }    int findKth(vector&lt;int&gt; &amp;nums,int left,int right,int k){        int index&#x3D;partition(nums,left,right);        if(index+1&#x3D;&#x3D;k)            return nums[index];        else if(index+1&lt;k)            return findKth(nums,index+1,right,k);        else if(index+1&gt;k)            return findKth(nums,left,index-1,k);        else            return -1;    }    int partition(vector&lt;int&gt;&amp; nums,int left,int right){        int pivot&#x3D;rand()%(right-left+1)+left;        swap(nums[left],nums[pivot]);        int temp&#x3D;nums[left];        int i&#x3D;left;        int j&#x3D;left+1;        while(j&lt;&#x3D;right){            if(nums[j]&gt;&#x3D;temp)                swap(nums[j],nums[++i]);            j++;        }        swap(nums[left],nums[i]);        return i;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
      <tag>Sorting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-207</title>
    <link href="/2020/03/10/LeetCode-207/"/>
    <url>/2020/03/10/LeetCode-207/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/10/LeetCode-207/LeetCode-207%5Ctest.png" srcset="/img/loading.gif" alt="207"></p><h3 id="å¦‚ä½•ç†è§£è¿™æ ·ä¸€ä¸ªé—®é¢˜"><a href="#å¦‚ä½•ç†è§£è¿™æ ·ä¸€ä¸ªé—®é¢˜" class="headerlink" title="å¦‚ä½•ç†è§£è¿™æ ·ä¸€ä¸ªé—®é¢˜"></a>å¦‚ä½•ç†è§£è¿™æ ·ä¸€ä¸ªé—®é¢˜</h3><blockquote><p>è¯¾ç¨‹1æ˜¯è¯¾ç¨‹0çš„å‰æœŸå¿…ä¿®è¯¾ç¨‹ï¼Œæ‰€ä»¥å­˜åœ¨1-&gt;0è¿™æ ·çš„ä¸€ç§æ˜ å°„å…³ç³»<br>é‚£ä¹ˆæ ¹æ®è¯¾ç¨‹è¡¨é‡Œçš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥ç›¸åº”çš„å»ºç«‹è¿™æ ·ä¸€å¼ è¯¾ç¨‹å›¾ã€‚<br>å›¾ä¸­æ¯ä¸€ä¸ªé¡¶ç‚¹å¯èƒ½æ²¡æœ‰å…¥åº¦(å› ä¸ºæ²¡æœ‰å‰æœŸå¿…ä¿®çš„è¯¾ç¨‹åŸºç¡€)ï¼Œ<br>è¿™æ ·çš„ä¸€ç³»åˆ—èŠ‚ç‚¹è‡ªç„¶ç¬¦åˆè¯¾ç¨‹çš„ä¿®è¯»è¦æ±‚ï¼Œæ˜¯è‡ªç„¶ç¬¦åˆçš„ã€‚é‚£ä¹ˆï¼Œæˆ‘ä»¬åªéœ€è¦å…³ç³»é‚£äº›å­˜åœ¨å…¥åº¦çš„é¡¶ç‚¹ï¼Œè§‚å¯Ÿå®ƒä»¬å†ç°æœ‰çš„æ¡ä»¶ä¸‹ï¼Œæ˜¯å¦èƒ½å¤Ÿæ»¡è¶³ï¼Œå¦‚æœå…¨éƒ¨éƒ½æ»¡è¶³äº†ï¼Œé‚£ä¹ˆå°±æ˜¯æœ‰æ•ˆçš„è¯¾ç¨‹ï¼Œåä¹‹åˆ™æ— æ•ˆã€‚</p></blockquote><h3 id="ç¬¬ä¸€ç§ç­–ç•¥ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢"><a href="#ç¬¬ä¸€ç§ç­–ç•¥ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢" class="headerlink" title="ç¬¬ä¸€ç§ç­–ç•¥ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢"></a>ç¬¬ä¸€ç§ç­–ç•¥ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢</h3><pre><code>class Solution {public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {        map&lt;int,set&lt;int&gt;&gt; adjacent;        vector&lt;int&gt; indegree(numCourses);        for(auto&amp; p:prerequisites){            adjacent[p[1]].insert(p[0]);            indegree[p[0]]++;        }        queue&lt;int&gt; todo;        for(int i&#x3D;0;i&lt;numCourses;i++){            if(!indegree[i])                todo.push(i);&#x2F;&#x2F;        }        int count&#x3D;0;        while(!todo.empty()){            auto vertex&#x3D;todo.front();            todo.pop();            auto t&#x3D;adjacent[vertex];            for(auto x:t){                --indegree[x];                if(!indegree[x])                        todo.push(x);            }            count++;        }        return count&#x3D;&#x3D;numCourses;    }};</code></pre><blockquote><p>æ¯ä¸€æ¬¡æ“ä½œæ—¶ï¼Œå…ˆæ‰£é™¤ä¸ç›®å‰è®¿é—®é¡¶ç‚¹ç›¸è¿çš„é‚»å±…ä»¬çš„å…¥åº¦ï¼Œç„¶åå¯¹äºæ¯ä¸€ä¸ªå…¥åº¦ä¸º0çš„é¡¶ç‚¹çš„æ‰€æœ‰é‚»å±…è¿›è¡Œéå†å¹¶å°†å®ƒä»¬å…¥é˜Ÿï¼Œå®Œæˆä¸€æ¬¡æ“ä½œï¼Œå°†å®Œæˆçš„è¯¾ç¨‹æ•°count++ï¼Œæœ€åå†ä¸è¯¾ç¨‹æ€»æ•°è¿›è¡Œæ¯”è¾ƒã€‚</p></blockquote><h3 id="ç¬¬äºŒç§ç­–ç•¥-æ·±åº¦ä¼˜å…ˆæœç´¢"><a href="#ç¬¬äºŒç§ç­–ç•¥-æ·±åº¦ä¼˜å…ˆæœç´¢" class="headerlink" title="ç¬¬äºŒç§ç­–ç•¥: æ·±åº¦ä¼˜å…ˆæœç´¢"></a>ç¬¬äºŒç§ç­–ç•¥: æ·±åº¦ä¼˜å…ˆæœç´¢</h3><pre><code>class Solution {public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {        map&lt;int,set&lt;int&gt;&gt; adjacent;        vector&lt;int&gt; outdegree(numCourses);        for(auto&amp; p:prerequisites){            adjacent[p[0]].insert(p[1]);            outdegree[p[1]]++;        }        stack&lt;int&gt; todo;        for(int i&#x3D;0;i&lt;numCourses;i++){            if(!outdegree[i])                todo.push(i);&#x2F;&#x2F;        }        int count&#x3D;0;        while(!todo.empty()){            auto vertex&#x3D;todo.top();            todo.pop();            auto t&#x3D;adjacent[vertex];            for(auto x:t){                --outdegree[x];                if(!outdegree[x])                        todo.push(x);            }            count++;        }        return count&#x3D;&#x3D;numCourses;    }};</code></pre><blockquote><p>ä¸ç¬¬ä¸€ç§æ–¹æ³•æ­£å¥½ç›¸åï¼Œæˆ‘ä»¬å¯¹é¡¶ç‚¹çš„å‡ºåº¦è¿›è¡Œè®¨è®ºã€‚é¡¶ç‚¹å‡ºåº¦ä¸º0çš„é‚£äº›ï¼Œä½œä¸ºæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œåº”è¯¥æ˜¯æœ€åè¾¾åˆ°ä½†æ˜¯æœ€å…ˆå®Œæˆè®¿é—®çš„é‚£äº›æœ«ç«¯ï¼Œæˆ‘ä»¬å‡è®¾è®¿é—®åˆ°äº†è¿™æ ·ä¸€ä¸ªé¡¶ç‚¹ï¼Œä»£è¡¨äº†æˆ‘ä»¬ä¿®è¯»å®Œäº†ä¸€é—¨è¯¾ç¨‹ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å»å¯»æ‰¾èƒ½å¤Ÿè®¿é—®åˆ°è¿™ä¸ªé¡¶ç‚¹çš„å‰é©±ä»¬ï¼Œæ³¨æ„å…ˆè¦å°†è¿™äº›å‰é©±ä»¬çš„å‡ºåº¦è¿›è¡Œä¿®æ”¹ã€‚å¦‚æœå‘ç°å‰é©±ä»¬çš„å‡ºåº¦ä¹Ÿå˜ä¸º0ï¼Œåˆ™æˆ‘ä»¬å°±æ‰¾åˆ°äº†è¿™æ ·ä¸€ç§å‰åå¯¹åº”å…³ç³»çš„è¯¾ç¨‹ï¼Œåå¤æ“ä½œç›´è‡³æ ˆç©ºã€‚æ³¨æ„å¦‚æœå­˜åœ¨ç¯å½¢ç»“æ„ï¼Œå®ƒä»¬é¡¶ç‚¹çš„å‡ºåº¦å¿…ç„¶ä¸ä¸º0ï¼ŒåŒæ—¶ä¹Ÿä¸å¯èƒ½åœ¨åˆæ³•è®¿é—®åå‘ç”Ÿå‡å°ï¼Œå› æ­¤å®ƒä»¬æ ¹æœ¬æ— æ³•è¢«è®¿é—®åˆ°ï¼Œcountä¸å¯èƒ½åˆ°è¾¾åŸå®šçš„è¯¾ç¨‹æ•°ï¼Œä¹Ÿå°±ä¸æ»¡è¶³æ¡ä»¶ã€‚</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Graph</tag>
      
      <tag>Breadth First Search</tag>
      
      <tag>Depth First Search</tag>
      
      <tag>Topological Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-84</title>
    <link href="/2020/03/10/LeetCode-84/"/>
    <url>/2020/03/10/LeetCode-84/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/10/LeetCode-84/aaa.jpg" srcset="/img/loading.gif" alt="aaa"></p><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        int n&#x3D;heights.size();        int m&#x3D;0;        for(int i&#x3D;0;i&lt;n;i++){            int k&#x3D;INT_MAX;            for(int j&#x3D;i;j&lt;n;j++){                k&#x3D;min(k,heights[j]);                m&#x3D;max(m,(j-i+1)*k);            }        }        return m;    }};</code></pre><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        int n&#x3D;heights.size();        int m&#x3D;0;        vector&lt;int&gt; leftMin(n,-1);        vector&lt;int&gt; rightMin(n,n);        for(int i&#x3D;1;i&lt;n;i++){            int j&#x3D;i-1;            while(j&gt;&#x3D;0&amp;&amp;heights[j]&gt;&#x3D;heights[i]){                j&#x3D;leftMin[j];            }            leftMin[i]&#x3D;j;        }        for(int i&#x3D;n-2;i&gt;&#x3D;0;i--){            int j&#x3D;i+1;            while(j&lt;n&amp;&amp;heights[j]&gt;&#x3D;heights[i]){                j&#x3D;rightMin[j];            }            rightMin[i]&#x3D;j;        }        for(int i&#x3D;0;i&lt;n;i++){            m&#x3D;max(m,heights[i]*(rightMin[i]-leftMin[i]-1));        }        return m;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-18</title>
    <link href="/2020/03/10/LeetCode-18/"/>
    <url>/2020/03/10/LeetCode-18/</url>
    
    <content type="html"><![CDATA[<p>LeetCode Næ•°ä¹‹å’Œé—®é¢˜-ver 3.0</p><p>  å››æ•°ä¹‹å’Œé—®é¢˜ï¼šç»™å®šä¸€ä¸ªåŒ…å« n ä¸ªæ•´æ•°çš„æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ targetï¼Œåˆ¤æ–­ nums ä¸­æ˜¯å¦å­˜åœ¨å››ä¸ªå…ƒç´  aï¼Œbï¼Œc å’Œ d ï¼Œä½¿å¾— a + b + c + d çš„å€¼ä¸ target ç›¸ç­‰ï¼Ÿæ‰¾å‡ºæ‰€æœ‰æ»¡è¶³æ¡ä»¶ä¸”ä¸é‡å¤çš„å››å…ƒç»„ã€‚</p><p>  æ³¨æ„ï¼šç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„å››å…ƒç»„ã€‚</p><p>ä¸€ç‚¹é—®é¢˜ï¼šå¦‚ä½•é¿å…é‡å¤çš„æ•°å­—åå¤çš„åŠ å…¥ç»“æœé›†åˆï¼Ÿ<br>æœ€ç›´æ¥çš„æƒ³æ³•æ˜¯å…ˆæš´åŠ›æšä¸¾å‡ºæ‰€æœ‰çš„å¯èƒ½ç»„åˆï¼Œå†ç”¨setå»é‡ï¼Œæ—¶é—´å¤æ‚åº¦O(N^4)-&gt;O(N^3)<br>ä½¿ç”¨target-nums[i]æ”¹è¿›å¾ªç¯ï¼Œæ—¶é—´å¤æ‚åº¦å¯ä¸‹é™è‡³O(N^3)<br>å¦‚ä½•å»é‡ï¼Ÿæ³¨æ„ä¸¤ä¸ªå†…éƒ¨çš„whileå¾ªç¯ï¼Œä¸¤ä¸ªifè¯­å¥</p><pre><code>if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])</code></pre> <ol><li>ä¸èƒ½é¢ å€’ä¸¤ä¸ªæ¡ä»¶çš„é¡ºåº</li><li>ä»i=1å¼€å§‹æ‰æœ‰å¯èƒ½æ‰§è¡Œè¯¥è¯­å¥ï¼Œä»è€Œè·³è¿‡å‰é¢çš„k-&gt;iä¸­çš„é‡å¤å…ƒç´ </li></ol><pre><code>while(k&lt;l&amp;&amp;nums[k]&#x3D;&#x3D;nums[k+1])  ++k;while(k&lt;l&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1])  --l;++k;--l;&#x2F;&#x2F;æ³¨æ„è¿™é‡Œï¼Œåˆ¤æ–­çš„è¾¹ç•Œéœ€è¦å†åŠ 1&#x2F;å‡1</code></pre><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="ä»¥ä¸‹æ˜¯ä¸€ç§è§£æ³•ï¼š"><a href="#ä»¥ä¸‹æ˜¯ä¸€ç§è§£æ³•ï¼š" class="headerlink" title="ä»¥ä¸‹æ˜¯ä¸€ç§è§£æ³•ï¼š"></a>ä»¥ä¸‹æ˜¯ä¸€ç§è§£æ³•ï¼š</h3><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;vector&lt;int&gt;&gt; res;        if(nums.empty())            return {};                sort(nums.begin(),nums.end());        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++){            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])  {                continue;                            }              int threeSum&#x3D;target-nums[i];            for(int j&#x3D;i+1;j&lt;n;j++){                if(j&gt;i+1&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]){                    continue;                                    }                    int twoSum&#x3D;threeSum-nums[j];                int k&#x3D;j+1;                int l&#x3D;n-1;                while(k&lt;l){                    if(nums[k]+nums[l]&#x3D;&#x3D;twoSum){                        res.push_back({nums[i],nums[j],nums[k],nums[l]});                        while(k&lt;l&amp;&amp;nums[k]&#x3D;&#x3D;nums[k+1]){                            ++k;                        }                        while(k&lt;l&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1]){                            --l;                        }                        ++k;--l;                      }                    else if(nums[k]+nums[l]&gt;twoSum){                        --l;                                            }                    else{                        ++k;                                            }                    }            }        }        return res;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Two pointers</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B-Tree dynamtic procedures/remove&amp;insert</title>
    <link href="/2020/03/09/B-Tree/"/>
    <url>/2020/03/09/B-Tree/</url>
    
    <content type="html"><![CDATA[<blockquote><p>B-æ ‘çš„æ“ä½œï¼šæ’å…¥ä¸åˆ é™¤</p></blockquote><h3 id="åŸºæœ¬æ¡†æ¶"><a href="#åŸºæœ¬æ¡†æ¶" class="headerlink" title="åŸºæœ¬æ¡†æ¶"></a>åŸºæœ¬æ¡†æ¶</h3><p>é¦–å…ˆï¼Œç”¨æŸ¥æ‰¾ç®—æ³•æ‰¾åˆ°å…³é”®ç å¯¹åº”èŠ‚ç‚¹åŠå…¶ç›´æ¥åç»§ï¼Œç±»ä¼¼äºæ‰§è¡ŒBSTçš„åˆ é™¤æ“ä½œï¼Œç„¶åäº¤æ¢å½“å‰èŠ‚ç‚¹ä¸ç›´æ¥åç»§ï¼Œå¹¶å°†äº¤æ¢åçš„ç›´æ¥åç»§å¤„çš„å¶å­èŠ‚ç‚¹åˆ é™¤ã€‚</p><pre><code>template&lt;typename T&gt; bool BTree&lt;T&gt;::remove(T const&amp; e){    BTNode&lt;T&gt;* v&#x3D;search(e);    if(!v)  return false;    Rank r&#x3D;v-&gt;key.search(e);    if(v-&gt;child[0]){&#x2F;&#x2F;å¦‚æœvä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå¿…ç„¶å­˜åœ¨ç›´æ¥åç»§        BTNode&lt;T&gt;* u&#x3D;v-&gt;child[r+1];        while(u-&gt;child[0])  u&#x3D;u-&gt;child[0];        v-&gt;key[r]&#x3D;u-&gt;key[0];        v-&gt;key.remove(r);        v-&gt;child.remove(r+1);        _size--;    }    solveUnderFlow(v);&#x2F;&#x2F;å¤„ç†ç”±äºåˆ é™¤å‘ç”Ÿçš„ä¸‹æº¢é—®é¢˜    return true;       }</code></pre><h3 id="ä¸‹æº¢é—®é¢˜"><a href="#ä¸‹æº¢é—®é¢˜" class="headerlink" title="ä¸‹æº¢é—®é¢˜"></a>ä¸‹æº¢é—®é¢˜</h3><p>ä¸‰ç§å¯èƒ½ï¼šå·¦ä¾§è¶³å¤Ÿå¤šï¼Œå³ä¾§è¶³å¤Ÿå¤šï¼Œå·¦å³éƒ½å³å°†ä¸‹æº¢</p><pre><code>template&lt;typename T&gt; void BTree&lt;T&gt;::solveUnderFlow(BTNode&lt;T&gt;* v){    if((_order+1)&#x2F;2&lt;&#x3D;v-&gt;child-&gt;size())&#x2F;&#x2F;æ²¡æœ‰å‘ç”Ÿä¸‹æº¢ï¼Œä¸éœ€è¦å˜åŒ–        return;    BTNode&lt;T&gt;* p&#x3D;v-&gt;parent;    if(!p){        if(!v-&gt;key.size()&amp;&amp;v-&gt;child[0]){            _root&#x3D;v-&gt;child[0];            _root-&gt;parent&#x3D;NULL;            v-&gt;child[0]&#x3D;NULL;            release(v);        }&#x2F;&#x2F;æ ‘æ ¹væ²¡æœ‰å…³é”®ç ï¼Œå´æœ‰å”¯ä¸€çš„éç©ºå­©å­        &#x2F;&#x2F;åˆ™å¯ä»¥é”€æ¯æ‰è¿™ä¸ªèŠ‚ç‚¹ï¼Œå¹¶å°†æ•´æ ‘é«˜åº¦ä¸‹é™ä¸€ä¸ªå•ä½               return;    }    Rank r&#x3D;0;    while(p-&gt;child[r]!&#x3D;v)   r++;    &#x2F;&#x2F;ç¡®å®švæ˜¯pçš„ç¬¬rä¸ªå­©å­ï¼Œæ­¤æ—¶ç”±äºvå¯èƒ½ä¸å«å…³é”®ç     &#x2F;&#x2F;æ‰€ä»¥ä¸èƒ½ç›´æ¥é€šè¿‡å…³é”®ç æŸ¥æ‰¾v    &#x2F;&#x2F;æƒ…å†µ1ï¼šå‘å·¦å…„å¼Ÿå€Ÿå…³é”®ç     if(r&gt;0){&#x2F;&#x2F;vä¸æ˜¯pçš„ç¬¬ä¸€ä¸ªå­©å­        BTNode&lt;T&gt;* ls&#x3D;p-&gt;child[r-1];&#x2F;&#x2F;æƒ³æƒ³ä¸­åºéå†çš„ç›´æ¥åç»§        if((_order+1)&#x2F;2&lt;ls-&gt;child.size()){&#x2F;&#x2F;å·¦å…„å¼Ÿå¤Ÿå€Ÿ            v-&gt;key.insert(0,p-&gt;key[r-1]);&#x2F;&#x2F;å…ˆä»çˆ¶äº²å€Ÿ1ä¸ª            p-&gt;key[r-1]&#x3D;ls-&gt;key.remove(ls-&gt;key.size()-1);&#x2F;&#x2F;å·¦å…„å¼Ÿç§»ç»™çˆ¶äº²            v-&gt;child.insert(0,ls-&gt;child.remove(ls-&gt;child.size()-1));&#x2F;&#x2F;å¼•ç”¨èŠ‚ç‚¹ä¹Ÿè¦ç›¸åº”çš„è½¬ç§»ç»™å³è¾¹çš„å…„å¼Ÿ        }        if(v-&gt;child[0]) v-&gt;child[0]-&gt;parent&#x3D;v;        &#x2F;&#x2F;ç§»å®Œäº†è®°å¾—æ›´æ–°parentå¼•ç”¨        return;    }    &#x2F;&#x2F;è‡³æ­¤ï¼Œå·¦å…„å¼Ÿè¦ä¹ˆä¸ºç©ºï¼Œè¦ä¹ˆä¸å¤Ÿå€Ÿ    &#x2F;&#x2F;æƒ…å†µ2ï¼šå‘å³å…„å¼Ÿå€Ÿå…³é”®ç     if(r&lt;p-&gt;child.size()){        BTNode&lt;T&gt;* rs&#x3D;p-&gt;child[r+1];        if((_order+1)&#x2F;2&lt;rs-&gt;child.size()){            v-&gt;key.insert(v-&gt;key.size(),p-&gt;key[r]);&#x2F;&#x2F;ä»çˆ¶äº²å€Ÿä¸€ä¸ªï¼Œæ’å…¥å·¦è¾¹æœ€å³ä¾§            p-&gt;key[r]&#x3D;rs-&gt;key.remove(0);            v-&gt;child.insert(v-&gt;child.size(),rs-&gt;child.remove(0));        }        if(v-&gt;child[v-&gt;child.size()-1])            v-&gt;child[v-&gt;child.size()-1]-&gt;parent&#x3D;v;       }    &#x2F;&#x2F;è‡³æ­¤ï¼Œå³å…„å¼Ÿè¦ä¹ˆä¸ºç©ºï¼Œè¦ä¹ˆä¸å¤Ÿå€Ÿ    &#x2F;&#x2F;æƒ…å†µ3ï¼Œå·¦å³å…„å¼Ÿè¦ä¹ˆå…¶ä¸€ä¸ºç©ºï¼Œè¦ä¹ˆéƒ½ä¸å¤Ÿå€Ÿ    if(r&gt;0){&#x2F;&#x2F;å‘å·¦å…„å¼Ÿåˆå¹¶        BTNode&lt;T&gt;* ls&#x3D;p-&gt;child[r-1];        ls-&gt;key.insert(ls-&gt;key.size(),p-&gt;key.remove(r-1));        p-&gt;child.remove(r);&#x2F;&#x2F;å°†pçš„ç¬¬r-1ä¸ªå…³é”®ç è½¬å…¥ls        ls-&gt;child.insert(ls-&gt;child.size(),v-&gt;child.remove(0));        if(ls-&gt;child[ls-&gt;child.size()-1])            ls-&gt;child[ls-&gt;child.size()-1]-&gt;parent&#x3D;ls;        while(!v-&gt;key.empty()){            ls-&gt;key.insert(ls-&gt;key.size(),v-&gt;key.remove(0));            ls-&gt;child.insert(ls-&gt;child.size(),v-&gt;child.remove(0));            if(ls-&gt;child[ls-&gt;child.size()-1])                ls-&gt;child[ls-&gt;child.size()-1]-&gt;parent&#x3D;ls;        }        release(v);    }    else{&#x2F;&#x2F;å‘å³å…„å¼Ÿåˆå¹¶        BTNode&lt;T&gt;* rs&#x3D;p-&gt;child[r+1];        rs-&gt;key.insert(0,p-&gt;key.remove(r));        p-&gt;child.remove(r);        rs-&gt;child.insert(0,v-&gt;child.remove(v-&gt;child.size()-1));        if(rs-&gt;child[0])            rs-&gt;child[0]-&gt;parent&#x3D;rs;        while(!v-&gt;key.empty()){            rs-&gt;key.insert(0,v-&gt;key.remove(v-&gt;key.size()-1));            rs-&gt;child.insert(0,v-&gt;key.remove(v-child.size()-1));            if(rs-&gt;child[0])                rs-&gt;child[0]-&gt;parent&#x3D;rs;        }        release(v);    }    solveUnderFlow(p);    return;}</code></pre><p>å¤æ‚åº¦ï¼šå¹³å‡åªæœ‰å¸¸æ•°æ¬¡çš„æ“ä½œã€‚æç«¯æƒ…å†µä¸ºO(logn)çš„æ—¶é—´å¤æ‚åº¦ã€‚</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/03/09/hello-world/"/>
    <url>/2020/03/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello!"></a>Hello!</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

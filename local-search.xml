<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1111</title>
    <link href="/2020/04/01/1111/"/>
    <url>/2020/04/01/1111/</url>
    
    <content type="html"><![CDATA[<pre><code>2333333</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rooms</title>
    <link href="/2020/03/31/rooms/"/>
    <url>/2020/03/31/rooms/</url>
    
    <content type="html"><![CDATA[<pre><code>class Solution {public:    void dfs(int i,vector&lt;vector&lt;int&gt;&gt;&amp; rooms,vector&lt;bool&gt;&amp; visited,int &amp;cnt){        for(int j:rooms[i]){            if(!visited[j]){                visited[j]&#x3D;true;                cnt++;                dfs(j,rooms,visited,cnt);            }        }    }    bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) {        int n&#x3D;rooms.size();        if(n&#x3D;&#x3D;0)            return true;        vector&lt;bool&gt; visited(n,false);        int cnt&#x3D;0;        visited[0]&#x3D;true;        cnt++;        dfs(0,rooms,visited,cnt);        return cnt&#x3D;&#x3D;n;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Depth First Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分割数组的最大值</title>
    <link href="/2020/03/26/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2020/03/26/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<pre><code>class Solution {public:    int splitArray(vector&lt;int&gt;&amp; nums, int m) {        long long left&#x3D;0,right&#x3D;0;        for(int num:nums){            left&#x3D;max(left,static_cast&lt;long long&gt;(num));            right+&#x3D;num;        }        &#x2F;&#x2F;[max(nums[0],nums[1],...),sum(nums[0],nums[1],...)]--&gt;subarray range        &#x2F;&#x2F;currsum++  need too much-&gt;curr&lt;res----&gt;left++        while(left-right){            long long mid&#x3D;(left+right)&#x2F;2,need&#x3D;1,curr&#x3D;0;            for(int num:nums){                if(curr+num&gt;mid){                    need++;                    curr&#x3D;0;                }                curr+&#x3D;num;            }            if(need&gt;m)                left&#x3D;mid+1;            else                right&#x3D;mid;        }        return left;    }};</code></pre><pre><code>class Solution {public:    int splitArray(vector&lt;int&gt;&amp; nums, int m) {        int n&#x3D;nums.size();        vector&lt;vector&lt;long long&gt; &gt; dp(n+1,vector&lt;long long&gt;(m+1,INT_MAX));        vector&lt;long long&gt; sub(n+1,0);        for(int i&#x3D;0;i&lt;n;i++){            sub[i+1]&#x3D;sub[i]+nums[i];        }        dp[0][0]&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;n;i++){            for(int j&#x3D;1;j&lt;&#x3D;m;j++){                for(int k&#x3D;0;k&lt;i;k++){                    dp[i][j]&#x3D;min(dp[i][j],max(dp[k][j-1],sub[i]-sub[k]));                }            }        }        return dp[n][m];    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>Greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maximum-rectangle</title>
    <link href="/2020/03/25/maximum-rectangle/"/>
    <url>/2020/03/25/maximum-rectangle/</url>
    
    <content type="html"><![CDATA[<p>很好的一道题。。。最好与84题一起食用</p><a id="more"></a><ol><li>暴力法：枚举每个可能的矩形位置X 显然过不去的<br>复杂度：设输入矩阵的行数为m，列数为n -&gt;O(m^3*n^3)  </li></ol><p>2.对每一列的最大宽度作DP，再遍历求解，DP表内垂直相邻的方向上可计算相应对应的矩形面积，其对应公共区域的面积为两个方向上最大宽度的最小值<em>高度<br>时间复杂度：O(mn)</em>O(n)=O(m*n^2) 空间复杂度：O(mn)</p><ol start="3"><li>对于以上方法的优化：计算最大宽度的优化，作自顶向下的分割<br>每一次对一整列求取最大高度与最大面积，不断更新每一列的最大高度，直接调用84题中的单调栈解法，就可以得出相应的行中最大的矩形面积() O(mn),O(n)<pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights){        int maxArea&#x3D;0;        stack&lt;int&gt; s;        int i&#x3D;0;        while(i&lt;heights.size()){            if(s.empty())                s.push(i++);            else{                int temp&#x3D;s.top();                if(heights[i]&gt;&#x3D;heights[temp]){                    s.push(i);                    i++;                }                else{&#x2F;&#x2F;单调栈，保证每次操作时栈内保证高度不减                &#x2F;&#x2F;若入栈元素高度小于栈顶元素，则出现了中间高两端低的情况                    &#x2F;&#x2F;保存栈顶高度                    int height&#x3D;heights[temp];                    s.pop();                    &#x2F;&#x2F;左边第一个小于当前柱子的下标                    int LeftLessMin&#x3D;s.empty()?-1:s.top();                    &#x2F;&#x2F;右边第一个小于当前柱子的下标                    int RightLessMin&#x3D;i;                    &#x2F;&#x2F;计算面积                    int area &#x3D;(RightLessMin-LeftLessMin-1)*height;                    maxArea&#x3D;max(area, maxArea);                }            }        }        while(!s.empty()){            int height&#x3D;heights[s.top()];            s.pop();            &#x2F;&#x2F;左边第一个小于当前柱子的下标            int LeftLessMin&#x3D;s.empty()?-1:s.top();            &#x2F;&#x2F;右边没有小于当前高度的柱子，所以赋值为数组的长度便于计算            int RightLessMin&#x3D;heights.size();            int area&#x3D;(RightLessMin-LeftLessMin-1)*height;            maxArea&#x3D;max(area,maxArea);        }        return maxArea;    }    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {        if(!matrix.size())            return 0;&#x2F;&#x2F;                vector&lt;int&gt; heights(matrix[0].size(),0);        int maxArea&#x3D;0;        for(int i&#x3D;0;i&lt;matrix.size();i++){            for(int j&#x3D;0;j&lt;matrix[0].size();j++){                if(matrix[i][j]&#x3D;&#x3D;&#39;1&#39;){                    heights[j]+&#x3D;1;                }                else                    heights[j]&#x3D;0;            }            maxArea&#x3D;max(maxArea,largestRectangleArea(heights));        }        return maxArea;    }};</code></pre></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单词拆分</title>
    <link href="/2020/03/24/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <url>/2020/03/24/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>dp[i] means whether the substr[0,i] can be broke down to words<br>dp[i]=true so it is possible, else it’s impossible.<br>do the process with each of the possible position, till the end.</p><pre><code>class Solution {public:    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {        int m&#x3D;s.length();        bool dp[m+1];        memset(dp,0,sizeof(dp));        dp[0]&#x3D;true;        unordered_set&lt;string&gt; dict(wordDict.begin(),wordDict.end());        int getMax&#x3D;0;        for(string s:wordDict){            getMax&#x3D;max(getMax,(int)s.length());        }        for(int i&#x3D;1;i&lt;&#x3D;m;i++){            for(int j&#x3D;max(0,i-getMax);j&lt;i;j++){                if(dp[j]&amp;&amp;dict.find(s.substr(j,i-j))!&#x3D;dict.end()){                    dp[i]&#x3D;true;                    break;                }            }        }        return dp[m];    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3n块披萨</title>
    <link href="/2020/03/23/3n%E5%9D%97%E6%8A%AB%E8%90%A8/"/>
    <url>/2020/03/23/3n%E5%9D%97%E6%8A%AB%E8%90%A8/</url>
    
    <content type="html"><![CDATA[<p>区间DP+2n操作<br>{}<br>//dp[l][r]=&gt;maxsize after taking all from left-&gt;right<br>//dp[l1][r2]=dp[l1][r1]+dp[l2][r2]—-&gt;l2==r1<br>//dp[l+1][mid]+slices[mid]+dp[mid+1][r-1]=&gt;dp[l][r]<br>//ring to list by double the size</p><p>class Solution {<br>    int dp[550<em>3][550</em>3];<br>public:<br>    int maxSizeSlices(vector<int>&amp; slices) {<br>        int n=slices.size();<br>        memset(dp,-1,sizeof(dp));<br>        for(int i=0;i&lt;2<em>n;i++){<br>            dp[i][i+2]=slices[(i+1)%n];//double the size to break the ring<br>        }<br>        for(int len=3;len&lt;n;len++){<br>            if(len%3!=2)<br>                continue;<br>            for(int left=0;left&lt;2</em>n;left++){<br>                int right=left+len;<br>                if(right&gt;=2*n)<br>                    continue;<br>                for(int mid=left+1;mid&lt;right;mid++){<br>                    if((mid-left-1)%3!=0)<br>                        continue;<br>                    if((right-mid-1)%3!=0)<br>                        continue;<br>                    int curr=slices[mid%n];<br>                    if(mid!=left+1){<br>                        if(dp[left+1][mid-1]==-1)<br>                            continue;<br>                        curr+=dp[left+1][mid-1];<br>                    }<br>                    if(mid!=right-1){<br>                        if(dp[mid+1][right-1]==-1)<br>                            continue;<br>                        curr+=dp[mid+1][right-1];<br>                    }<br>                    dp[left][right]=max(dp[left][right],curr);<br>                }<br>                for(int mid=left;mid&lt;right;mid++){<br>                    if(dp[left][mid]==-1)<br>                        continue;<br>                    if(dp[mid+1][right]==-1)<br>                        continue;<br>                    dp[left][right]=max(dp[left][right],dp[left][mid]+dp[mid+1][right]);<br>                }<br>            }<br>        }<br>        int res=-1;<br>        for(int i=0;i&lt;n;i++){<br>            if(dp[i][i+n-1]!=-1)<br>                res=max(res,dp[i][i+n-1]);<br>        }<br>        return res;<br>    }<br>};<br>{}</int></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>检查有效路径</title>
    <link href="/2020/03/22/%E6%A3%80%E6%9F%A5%E6%9C%89%E6%95%88%E8%B7%AF%E5%BE%84/"/>
    <url>/2020/03/22/%E6%A3%80%E6%9F%A5%E6%9C%89%E6%95%88%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>四因子</title>
    <link href="/2020/03/22/%E5%9B%9B%E5%9B%A0%E5%AD%90/"/>
    <url>/2020/03/22/%E5%9B%9B%E5%9B%A0%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<pre><code>class Solution {public:    int sumFourDivisors(vector&lt;int&gt;&amp; nums) {        int res&#x3D;0;        for(int i:nums){            int count&#x3D;0;            int sum&#x3D;0;            for(int k&#x3D;1;k*k&lt;&#x3D;i;k++){                if(i%k&#x3D;&#x3D;0){                    if(k*k&#x3D;&#x3D;i){                        count++;                        sum+&#x3D;k;                    }                    else{                        count+&#x3D;2;                        sum&#x3D;sum+k+i&#x2F;k;                       }                }                if(count&gt;4){                    break;                    sum&#x3D;0;                }               }            if(count&#x3D;&#x3D;4)                res+&#x3D;sum;        }        return res;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长快乐前缀</title>
    <link href="/2020/03/22/%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%89%8D%E7%BC%80/"/>
    <url>/2020/03/22/%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<p>我裂开了,…我不会快乐了</p><a id="more"></a><p>KMP表里求的是真前缀，真后缀相等的最大长度！！！<br>稍做改动把整个字符串的前后匹配位置值加入，再直接取文本字符串从这个位置到末尾的子串就行了！！！</p><pre><code>class Solution {public:    string longestPrefix(string s) {        int m&#x3D;s.length();        int i&#x3D;0,j&#x3D;-1;        int *next&#x3D;new int[m+1];        next[0]&#x3D;-1;        while(i&lt;&#x3D;m-1){            if(j&lt;0||s[i]&#x3D;&#x3D;s[j]){                i++;j++;                next[i]&#x3D;j;            }            else                j&#x3D;next[j];        }        cout&lt;&lt;next[m];        return s.substr(m-next[m],next[m]);    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安排电影院座位</title>
    <link href="/2020/03/22/%E5%AE%89%E6%8E%92%E7%94%B5%E5%BD%B1%E9%99%A2%E5%BA%A7%E4%BD%8D/"/>
    <url>/2020/03/22/%E5%AE%89%E6%8E%92%E7%94%B5%E5%BD%B1%E9%99%A2%E5%BA%A7%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p>{}<br>class Solution {<br>public:<br>    int cnt=0;<br>    map&lt;int,int&gt; id;<br>    vector<int> r[10010];<br>    int maxNumberOfFamilies(int n, vector&lt;vector<int>&gt;&amp; reservedSeats) {<br>        for(int i=0;i&lt;reservedSeats.size();++i)<br>        {<br>            vector<int> a=reservedSeats[i];<br>            if(id[a[0]]==0)id[a[0]]=++cnt;<br>            r[id[a[0]]].push_back(a[1]);<br>        }<br>        int ans=0;<br>        for(int i=1;i&lt;=cnt;++i)<br>        {<br>            bool c1=1,c2=1,c3=1;<br>            for(int j=0;j&lt;r[i].size();++j)<br>            {<br>                if(r[i][j]==2)c1=0;<br>                if(r[i][j]==3)c1=0;<br>                if(r[i][j]==4)c1=c2=0;<br>                if(r[i][j]==5)c1=c2=0;<br>                if(r[i][j]==6)c3=c2=0;<br>                if(r[i][j]==7)c3=c2=0;<br>                if(r[i][j]==8)c3=0;<br>                if(r[i][j]==9)c3=0;<br>            }<br>            if(c1&amp;&amp;c3){ans+=2;continue;}<br>            if(c1 || c2 || c3)ans++;<br>        }<br>        return (long long)(n-cnt)*2+ans;<br>    }<br>};<br>{}</int></int></int></p><p>{}<br>class Solution {<br>    public int maxSizeSlices(int[] slices) {<br>        int length = slices.length;<br>        int picks = length / 3;<br>        // dp[i][j][s] 表示前i块披萨，拿了j块，最大值是多少，s表示第i块披萨是要还是不要<br>        int[][][] dp = new int[length][picks + 1][2];</p><pre><code>    // 分第一块要和第一块不要两种情况    int result = 0;    // 第一块要    dp[0][1][1] = slices[0];    for (int i = 1; i &lt; length; ++i) {        if (i == length - 1) {            // 对于最后一块pisa            // 第一块要了，那么它必须不能要            continue;        }        for (int j = 1; j &lt;= picks; ++j) {            // 对于第二块，只能选择不要            if (i == 1) {                dp[i][j][0] = dp[i - 1][j][1];                continue;            }            // 对于第i块披萨，如果要，那么最大值为i-1不要，拿了j-1块            dp[i][j][1] = dp[i - 1][j - 1][0] + slices[i];            // 如果不要，那么最大值为i-1不要，拿了j块，或i-1要，拿了j块            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1]);        }        result = Math.max(result, Math.max(dp[i][picks][1], dp[i][picks][0]));    }    // 第一块不要    dp[0][1][1] = 0;    // 第二块可以要，也可以不要，所以不需要特殊处理    for (int i = 1; i &lt; length; ++i) {        for (int j = 1; j &lt;= picks; ++j) {            // 对于第i块披萨，如果要，那么最大值为i-1不要，拿了j-1块            dp[i][j][1] = dp[i - 1][j - 1][0] + slices[i];            // 如果不要，那么最大值为i-1不要，拿了j块，或i-1要，拿了j块            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1]);        }        result = Math.max(result, Math.max(dp[i][picks][1], dp[i][picks][0]));    }    return result;}</code></pre><p>}<br>{}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>朋友圈</title>
    <link href="/2020/03/20/%E6%9C%8B%E5%8F%8B%E5%9C%88/"/>
    <url>/2020/03/20/%E6%9C%8B%E5%8F%8B%E5%9C%88/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><pre><code>class UnionFind{    private:        int Count;        vector&lt;int&gt; parent;        vector&lt;int&gt; size;    public:        UnionFind(int n){            this-&gt;Count&#x3D;n;            for(int i&#x3D;0;i&lt;n;i++){                parent.push_back(i);                size.push_back(1);            }        }        int find(int p){            while(p!&#x3D;parent[p]){                parent[p]&#x3D;parent[parent[p]];                p&#x3D;parent[p];            }            return p;        }        void Union(int p,int q){            int rootP&#x3D;find(p);            int rootQ&#x3D;find(q);            if(connected(p,q))    return;            if(size[rootP]&gt;size[rootQ]){                parent[rootQ]&#x3D;rootP;                size[rootP]+&#x3D;size[rootQ];            }            else{                parent[rootP]&#x3D;rootQ;                size[rootQ]+&#x3D;size[rootP];            }            Count--;        }        bool connected(int p,int q){            int rootP&#x3D;find(p);            int rootQ&#x3D;find(q);            return rootP&#x3D;&#x3D;rootQ;        }        int count(){return Count;}};class Solution {   public:    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {        int row&#x3D;M.size();        int col&#x3D;M[0].size();        UnionFind A(row);        for(int i&#x3D;0;i&lt;row;i++){            for(int j&#x3D;0;j&lt;col;j++){                if(M[i][j]&#x3D;&#x3D;1){                    A.Union(i,j);                }            }        }        return A.count();    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Union Find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻找峰值</title>
    <link href="/2020/03/20/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <url>/2020/03/20/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><pre><code>class Solution {public:    int findPeakElement(vector&lt;int&gt;&amp; nums) {        int l&#x3D;0,r&#x3D;nums.size()-1;        while(l&lt;r){            int mi&#x3D;((r-l)&gt;&gt;1)+l;            if(nums[mi]&gt;nums[mi+1]){                r&#x3D;mi;            }            else{                l&#x3D;mi+1;            }        }        return l;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小的k个数</title>
    <link href="/2020/03/20/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <url>/2020/03/20/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<pre><code>class Solution {public:    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) {        priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; pq;        int size&#x3D;arr.size();        if(k&gt;size||k&#x3D;&#x3D;0)            return {};        for(int i&#x3D;0;i&lt;k;i++){            pq.push(arr[i]);        }        for(int i&#x3D;k;i&lt;size;i++){            int temp&#x3D;pq.top();            if(temp&gt;arr[i]){                pq.pop();                pq.push(arr[i]);            }        }        vector&lt;int&gt; res;        while(!pq.empty()){            res.push_back(pq.top());            pq.pop();        }        return res;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
      <tag>Priority Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编辑距离</title>
    <link href="/2020/03/19/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2020/03/19/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p>非常有趣的一道题</p><a id="more"></a><pre><code>class Solution {public:    int minDistance(string word1, string word2) {        int m&#x3D;word1.length();        int n&#x3D;word2.length();        int dp[m+1][n+1];        for(int i&#x3D;0;i&lt;m+1;i++){            dp[i][0]&#x3D;i;&#x2F;&#x2F;i-&gt;0需要i步操作        }        for(int j&#x3D;0;j&lt;n+1;j++){            dp[0][j]&#x3D;j;&#x2F;&#x2F;0-&gt;j需要j步操作        }        for(int i&#x3D;1;i&lt;m+1;i++){            for(int j&#x3D;1;j&lt;n+1;j++){                if(word1[i-1]&#x3D;&#x3D;word2[j-1]){                    dp[i][j]&#x3D;dp[i-1][j-1];&#x2F;&#x2F;如果原字符串中S1第i个与S2第j个相同，则不需要作任何操作                }                else{                    dp[i][j]&#x3D;1+min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1]));&#x2F;&#x2F;否则从插入，替换，删除中选取代价最小的并更新                }            }        }        return dp[m][n];    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小覆盖子串</title>
    <link href="/2020/03/19/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/03/19/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>滑动窗口。。。</p><a id="more"></a><pre><code>怎么说呢，这题就是很恶心的那种🤢一个简单明了的思路就是维护这样一个窗口，固定一个左端，右端可以不断地扩展。class Solution {public:    string minWindow(string s, string t) {        if(s.size()&lt;t.size())            return &quot;&quot;;        int sFreq[64]&#x3D;{0};        int tFreq[64]&#x3D;{0};        for(int i&#x3D;0;i&lt;t.size();i++){            tFreq[t[i]-&#39;A&#39;]++;        }        int left&#x3D;0;        int right&#x3D;-1;        int border[2]&#x3D;{-1,s.size()-1};        while(left&lt;&#x3D;s.size()-t.size()){            if(right-left+1&lt;t.size()){                if(right+1&lt;s.size()){                    sFreq[s[++right]-&#39;A&#39;]++;                    continue;                }                else                    break;            }            int i&#x3D;0;            while(i&lt;64){                if(sFreq[i]&lt;tFreq[i])                    break;                i++;            }            if(i&lt;64){                if(right+1&lt;s.size())                    sFreq[s[++right]-&#39;A&#39;]++;                else                    break;            }            else{                if(right-left+1&#x3D;&#x3D;t.size())                    return string(s.begin()+left,s.begin()+right+1);                else{                    if(right-left&lt;border[1]-border[0]){                        border[0]&#x3D;left;                        border[1]&#x3D;right;                    }                    sFreq[s[left++]-&#39;A&#39;]--;                }                }        }        return border[0]&#x3D;&#x3D;-1?&quot;&quot;:string(s.begin()+border[0],s.begin()+border[1]+1);    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Sliding Window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路径总和III</title>
    <link href="/2020/03/18/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/"/>
    <url>/2020/03/18/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/</url>
    
    <content type="html"><![CDATA[<pre><code>&#x2F;** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; *&#x2F;class Solution {    unordered_map&lt;int,int&gt; count;public:    int pathSum(TreeNode* root,int sum) {        count[0]&#x3D;1;        return prefix_sum(root,sum,0);    }    int prefix_sum(TreeNode* root,int sum,int prefix){        if(!root)            return 0;        int res&#x3D;0;        prefix+&#x3D;root-&gt;val;        res+&#x3D;count[prefix-sum];        count[prefix]++;        res+&#x3D;prefix_sum(root-&gt;left,sum,prefix)+prefix_sum(root-&gt;right,sum,prefix);        count[prefix]--;        return res;    }};</code></pre><p>双重递归：每一个节点向下的递归中嵌套从该节点出发向下探索路径的递归。<br>采用更好理解的前缀法：前缀是到达该节点的路径上所有节点的数值总和。<br>所以，A节点处发现前缀为prefix，如果要找到符合条件的路径就意味着B处的前缀应该是prefix-sum，从而有了上述的算法是，把这一点之前的路径先进行计算，并递归考察向下递归的可能，回溯时注意要将出现prefix前缀的次数进行修改。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路径总和II</title>
    <link href="/2020/03/18/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/"/>
    <url>/2020/03/18/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/</url>
    
    <content type="html"><![CDATA[<pre><code>    路</code></pre><a id="more"></a><pre><code>&#x2F;** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; *&#x2F;class Solution {    vector&lt;vector&lt;int&gt;&gt; res;public:    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {        if(!root)            return res;        vector&lt;int&gt; path;        travToLeaf(root,path,sum);        return res;    }    void travToLeaf(TreeNode* root,vector&lt;int&gt; path,int sum){        if(!root-&gt;left&amp;&amp;!root-&gt;right){            path.push_back(root-&gt;val);            if(add(path)&#x3D;&#x3D;sum){                res.push_back(path);            }            return;        }        else if(root-&gt;left&amp;&amp;root-&gt;right){            path.push_back(root-&gt;val);            travToLeaf(root-&gt;left,path,sum);            travToLeaf(root-&gt;right,path,sum);        }        else if(root-&gt;left){            path.push_back(root-&gt;val);            travToLeaf(root-&gt;left,path,sum);        }        else{            path.push_back(root-&gt;val);            travToLeaf(root-&gt;right,path,sum);        }    }    inline int add(vector&lt;int&gt; path){        int sum&#x3D;0;        for(int i:path)            sum+&#x3D;i;        return sum;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩形重叠</title>
    <link href="/2020/03/18/%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/"/>
    <url>/2020/03/18/%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</url>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><pre><code>class Solution {public:    bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) {        int x11&#x3D;rec1[0];        int y11&#x3D;rec1[1];        int x21&#x3D;rec1[2];        int y21&#x3D;rec1[3];        bool out&#x3D;((rec2[0]&gt;&#x3D;x21)||(rec2[2]&lt;&#x3D;x11))||((rec2[1]&gt;&#x3D;y21)||(rec2[3]&lt;&#x3D;y11));        return !out;    }};</code></pre><p>就酱，数学问题，可以更加简化-&gt;1行代码</p>]]></content>
    
    
    
    <tags>
      
      <tag>Brute Force</tag>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重排链表</title>
    <link href="/2020/03/17/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/03/17/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>自己又变菜了<br>明明链表就那么几个花样：头节点，快慢指针，插入删除<br>写起来就BUG无限，Endless Bugs Most Beautiful</p><a id="more"></a><pre><code>&#x2F;** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; *&#x2F;class Solution {public:    void reorderList(ListNode* head) {        if(!head||!head-&gt;next)            return;        ListNode* slow&#x3D;head;        ListNode* fast&#x3D;head;        while(fast&amp;&amp;fast-&gt;next){            slow&#x3D;slow-&gt;next;            fast&#x3D;fast-&gt;next-&gt;next;        }        ListNode* reversed&#x3D;slow-&gt;next;        slow-&gt;next&#x3D;NULL;        reversed&#x3D;reverse(reversed);        ListNode* temp&#x3D;head;        while(temp&amp;&amp;reversed){            ListNode* p&#x3D;reversed;            reversed&#x3D;reversed-&gt;next;            ListNode* q&#x3D;temp-&gt;next;            p-&gt;next&#x3D;temp-&gt;next;            temp-&gt;next&#x3D;p;                        temp&#x3D;q;        }    }    ListNode* reverse(ListNode* head){        ListNode* prev&#x3D;NULL;        ListNode* curr&#x3D;head;        ListNode* temp;        while(curr){            temp&#x3D;curr-&gt;next;            curr-&gt;next&#x3D;prev;            prev&#x3D;curr;            curr&#x3D;temp;        }        return prev;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linked List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表的插入排序</title>
    <link href="/2020/03/17/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/03/17/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>插入排序妙啊啊啊啊啊啊啊啊，我选择归并排序(逃)。</p><a id="more"></a><pre><code>&#x2F;** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; *&#x2F;class Solution {public:    ListNode* insertionSortList(ListNode* head) {       ListNode* dummy&#x3D;new ListNode(0);       ListNode* prev;       dummy-&gt;next&#x3D;head;       while(head&amp;&amp;head-&gt;next){           if(head-&gt;val&lt;&#x3D;head-&gt;next-&gt;val){               head&#x3D;head-&gt;next;               continue;           }           prev&#x3D;dummy;           while(prev-&gt;next-&gt;val&lt;head-&gt;next-&gt;val){               prev&#x3D;prev-&gt;next;           }           ListNode* curr&#x3D;head-&gt;next;           head-&gt;next&#x3D;curr-&gt;next;           curr-&gt;next&#x3D;prev-&gt;next;           prev-&gt;next&#x3D;curr;       }       return dummy-&gt;next;    }};</code></pre><ol><li><p>确定已排序区域，用一个指针维护端点（这里用head）</p></li><li><p>找到已排序区域的 下一个元素（就是第一个未排序的元素）==head-&gt;next</p></li><li><p>找到这个元素在排序区域内的位置，就是用prev来确定</p></li><li><p>将该元素插入这个位置，移动排序区域的位置（head）</p></li><li><p>一遍又一遍的重复这个操作,直到最后一个元素也被排序</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linked List</tag>
      
      <tag>Sorting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU设计</title>
    <link href="/2020/03/17/LRU%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/03/17/LRU%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>LRU Cache</p><a id="more"></a><blockquote><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶:</p><p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例:</p><p>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4</p><p>来源：力扣（LeetCode）-146</p></blockquote><p>hash table+ list的结构<br>首先要在O(1)的时间查找，最直接的就是hash<br>接下来还需要O(1)的时间进行动态操作，就需要用到List的结构<br>综合起来就是一个类似有序字典的数据结构。<br>通过维护列表的长度代表缓存容量，桶结构中存放指向列表的迭代器(指针)<br>同时每次get操作都要相应的更新表首位置，更新状态。此时位于表末的元素就一定是最久没有访问的元素，从而将其弹出，再插入新元素。</p><pre><code>class LRUCache {public:    LRUCache(int capacity):cap(capacity) {    }        int get(int key) {        auto it&#x3D;m.find(key);        if(it&#x3D;&#x3D;m.end())            return -1;        int val&#x3D;it-&gt;second-&gt;second;        _list.erase(it-&gt;second);        _list.push_front(make_pair(key,val));        m[key]&#x3D;_list.begin();        return it-&gt;second-&gt;second;    }    void put(int key, int value) {        auto it&#x3D;m.find(key);        if(it!&#x3D;m.end()){            _list.erase(it-&gt;second);        }        _list.push_front(make_pair(key,value));        m[key]&#x3D;_list.begin();        if(_list.size()&gt;cap){            int key&#x3D;_list.back().first;            m.erase(key);            _list.pop_back();        }    }private:    unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; m;    list&lt;pair&lt;int,int&gt;&gt; _list;    int cap;};&#x2F;** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj &#x3D; new LRUCache(capacity); * int param_1 &#x3D; obj-&gt;get(key); * obj-&gt;put(key,value); *&#x2F; </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Hashing</tag>
      
      <tag>Designing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈实现队列</title>
    <link href="/2020/03/17/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2020/03/17/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<pre><code>假象。</code></pre><a id="more"></a><p>一个栈就是普通的栈，再用一个栈转移元素用<br>当有元素入队了，压入普通的栈；<br>当有元素出队了，先把栈上除栈底以外的全部转移，把栈底元素返回并弹出<br>此后如果再出队，此时经刚刚的操作，另一个栈中元素顺序发生的奇妙的转变，直接调用pop就是队列顺序的出队，直到另一个栈空。<br>peek就是pop没有pop的操作😂😂😂</p><pre><code>class MyQueue {public:    &#x2F;** Initialize your data structure here. *&#x2F;    MyQueue() {    }        &#x2F;** Push element x to the back of queue. *&#x2F;    void push(int x) {        front.push(x);    }        &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;    int pop() {        if(rear.empty()){            while(!front.empty()){                rear.push(front.top());                front.pop();            }        }        int temp&#x3D;rear.top();        rear.pop();        return temp;    }        &#x2F;** Get the front element. *&#x2F;    int peek() {        if(rear.empty()){            while(!front.empty()){                rear.push(front.top());                front.pop();                            }        }        return rear.top();    }        &#x2F;** Returns whether the queue is empty. *&#x2F;    bool empty() {        return front.empty()&amp;&amp;rear.empty();    }private:    stack&lt;int&gt; front;    stack&lt;int&gt; rear;};&#x2F;** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj &#x3D; new MyQueue(); * obj-&gt;push(x); * int param_2 &#x3D; obj-&gt;pop(); * int param_3 &#x3D; obj-&gt;peek(); * bool param_4 &#x3D; obj-&gt;empty(); *&#x2F;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串压缩</title>
    <link href="/2020/03/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
    <url>/2020/03/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<p>比较简单的每日一题~</p><a id="more"></a><p>数吧，没想到什么好办法QAQ</p><pre><code>class Solution {public:    string compressString(string S) {        int len&#x3D;S.length();        string str;        for(int i&#x3D;0;i&lt;len;i++){            str+&#x3D;S[i];            int count&#x3D;1;            while(S[i]&#x3D;&#x3D;S[i+1]&amp;&amp;i&lt;len-1){                i++;                count++;            }            str+&#x3D;to_string(count);        }        int len1&#x3D;str.length();        if(len1&gt;&#x3D;len){            return S;        }        else            return str;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拼写单词</title>
    <link href="/2020/03/17/%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/"/>
    <url>/2020/03/17/%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p>Brute Force…</p><a id="more"></a><p>直接散列表，快乐++<br>（其实这里只有26个字母，Dark不必哈希，只要维护一个数组😂<br>当然内存很爆炸啦😂😂😂😂😂</p><pre><code>class Solution {public:    int countCharacters(vector&lt;string&gt;&amp; words, string chars) {        int res&#x3D;0;        unordered_map&lt;char,int&gt; table;        for(char c:chars){            table[c]++;        }        unordered_map&lt;char,int&gt; temp&#x3D;table;        for(string s:words){            int count&#x3D;0;            for(char d:s){                if(temp.find(d)!&#x3D;temp.end()&amp;&amp;temp[d]&gt;0){                    count++;                    temp[d]--;                    continue;                }                else{                    count&#x3D;0;                    break;                                    }            }            temp&#x3D;table;            res+&#x3D;count;        }        return res;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Hashing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>岛屿最大面积</title>
    <link href="/2020/03/15/%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <url>/2020/03/15/%E5%B2%9B%E5%B1%BF%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<p>岛屿系列No.2<br>  <a id="more"></a></p><pre><code>class Solution {    int dx[4]&#x3D;{1,-1,0,0};    int dy[4]&#x3D;{0,0,1,-1};public:    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        int row&#x3D;grid.size();        int col&#x3D;grid[0].size();        int res&#x3D;0;        deque&lt;pair&lt;int,int&gt;&gt; nodes;        for(int i&#x3D;0;i&lt;row;i++){            for(int j&#x3D;0;j&lt;col;j++){                int area&#x3D;0;                nodes.push_back(make_pair(i,j));                while(!nodes.empty()){                    int x&#x3D;nodes.front().first;                    int y&#x3D;nodes.front().second;                    nodes.pop_front();                    if(!ingrid(x,y,row,col)||grid[x][y]&#x3D;&#x3D;0)    continue;                    area++;                    grid[x][y]&#x3D;0;                    for(int k&#x3D;0;k&lt;4;k++){                        nodes.push_back(make_pair(x+dx[k],y+dy[k]));                    }                }                res&#x3D;max(res,area);            }        }        return res;    }    bool ingrid(int i,int j,int row,int col){        return (i&gt;&#x3D;0&amp;&amp;i&lt;row)&amp;&amp;(j&gt;&#x3D;0&amp;&amp;j&lt;col);    }};</code></pre><p>当然，其实DFS更简单直观的说，可以直接DFS函数，也可以直接用栈模拟DFS。 把4个方向进行搜索，面积增长，岛屿探索完就置0避免反复探索，最后返回面积中最大的即可。<br>其实，并查集也可以。把所有为1的连通域的子节点数进行统计，求最大值也对。</p><pre><code>class Solution {    int maxArea&#x3D;0;    vector&lt;int&gt; parent;    vector&lt;int&gt; size;public:            void UnionFind(int n){        parent&#x3D;vector&lt;int&gt;(n,-1);        size&#x3D;vector&lt;int&gt;(n,0);    }    int find(int p){        while(p!&#x3D;parent[p]){            parent[p]&#x3D;parent[parent[p]];            p&#x3D;parent[p];        }        return p;    }    bool connected(int p,int q){        int rootP&#x3D;find(p);        int rootQ&#x3D;find(q);        return rootP&#x3D;&#x3D;rootQ;        }       void Union(int p,int q){        int rootP&#x3D;find(p);            int rootQ&#x3D;find(q);            if(connected(p,q))    return;            if(size[rootP]&gt;size[rootQ]){                parent[rootQ]&#x3D;rootP;                size[rootP]+&#x3D;size[rootQ];                maxArea&#x3D;max(size[rootP],maxArea);            }            else{                parent[rootP]&#x3D;rootQ;                size[rootQ]+&#x3D;size[rootP];                maxArea&#x3D;max(size[rootQ],maxArea);            }        }         inline bool inGrid(int x,int y,int row,int col){        return (x&gt;&#x3D;0&amp;&amp;x&lt;row)&amp;&amp;(y&gt;&#x3D;0&amp;&amp;y&lt;col);    }    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        int row&#x3D;grid.size();        if(row&#x3D;&#x3D;0)            return 0;        int col&#x3D;grid[0].size();        UnionFind(row*col);        for(int m&#x3D;0;m&lt;row;m++){            for(int n&#x3D;0;n&lt;col;n++){                if(grid[m][n]&#x3D;&#x3D;1){                    parent[m*col+n]&#x3D;m*col+n;                    size[m*col+n]&#x3D;1;                }            }        }        bool iszero&#x3D;true;        for(int i&#x3D;0;i&lt;row;i++){            for(int j&#x3D;0;j&lt;col;j++){                if(grid[i][j]&#x3D;&#x3D;1){                    iszero&#x3D;false;                    maxArea&#x3D;max(maxArea,1);                    if(i&gt;0&amp;&amp;grid[i-1][j]&#x3D;&#x3D;1){                           Union(i*col+j,(i-1)*col+j);                    }                    if(j&gt;0&amp;&amp;grid[i][j-1]&#x3D;&#x3D;1){                        Union(i*col+j,i*col+j-1);                     }                 }            }        }        if(iszero){            return 0;        }        else            return maxArea;    }};</code></pre><p>我终于写出来了！！！！！bug无数的并茶几啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊</p>]]></content>
    
    
    
    <tags>
      
      <tag>Breadth First Search</tag>
      
      <tag>Depth First Search</tag>
      
      <tag>Union Find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大团队表现值</title>
    <link href="/2020/03/15/%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%98%9F%E8%A1%A8%E7%8E%B0%E5%80%BC/"/>
    <url>/2020/03/15/%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%98%9F%E8%A1%A8%E7%8E%B0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p> 优先级队列是什么？我还没学到…😭<br> <a id="more"></a><br>公司有编号为 1 到 n 的 n 个工程师，给你两个数组 speed 和 efficiency ，其中 speed[i] 和 efficiency[i] 分别代表第 i 位工程师的速度和效率。请你返回由最多 k 个工程师组成的 ​​​​​​最大团队表现值 ，由于答案可能很大，请你返回结果对 10^9 + 7 取余后的结果。</p><p>团队表现值 的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。</p><p>示例 1：</p><p>输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2<br>输出：60<br>解释：<br>我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。</p><p>示例 2：</p><p>输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3<br>输出：68<br>解释：<br>此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。</p><p>示例 3：</p><p>输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4<br>输出：72</p><p>提示：</p><pre><code>1 &lt;= n &lt;= 10^5speed.length == nefficiency.length == n1 &lt;= speed[i] &lt;= 10^51 &lt;= efficiency[i] &lt;= 10^81 &lt;= k &lt;= n</code></pre><p>来源：力扣（LeetCode）</p><pre><code>class Solution {struct Engineer {int64_t s;int64_t e;Engineer(int64_t _s, int64_t _e) : s(_s), e(_e) {}bool operator &lt; (const Engineer &amp;r) const {return this-&gt;e &gt; r.e;}};vector&lt;Engineer&gt; data;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;public:int maxPerformance(int n, vector&lt;int&gt;&amp; speed, vector&lt;int&gt;&amp; efficiency, int k) {for(int i &#x3D; 0; i &lt; n; i++) {data.push_back(Engineer(speed[i], efficiency[i]));}sort(data.begin(), data.end());int64_t sum &#x3D; 0, anw &#x3D; 0;for(int i &#x3D; 0; i &lt; n; i++) {            sum +&#x3D; data[i].s;pq.push(data[i].s);if(pq.size() &gt; size_t(k)) {int64_t tmp &#x3D; pq.top();pq.pop();sum -&#x3D; tmp;}anw &#x3D; max(anw, sum * data[i].e);}return anw%(1000000007);}};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Priority Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>_200_岛屿数量</title>
    <link href="/2020/03/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <url>/2020/03/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>试试看并查集的方法：</p><a id="more"></a><h3 id="噔-噔-咚"><a href="#噔-噔-咚" class="headerlink" title="噔  噔  咚"></a>噔  噔  咚</h3><pre><code>class UnionFind{    private:        int Count;        vector&lt;int&gt; parent;        vector&lt;int&gt; size;    public:        UnionFind(int n){            this-&gt;Count&#x3D;n;            for(int i&#x3D;0;i&lt;n;i++){                parent.push_back(i);                size.push_back(1);            }        }        int find(int p){            while(p!&#x3D;parent[p]){                parent[p]&#x3D;parent[parent[p]];                p&#x3D;parent[p];            }            return p;        }        void Union(int p,int q){            int rootP&#x3D;find(p);            int rootQ&#x3D;find(q);            if(connected(p,q))    return;            if(size[rootP]&gt;size[rootQ]){                parent[rootQ]&#x3D;rootP;                size[rootP]+&#x3D;size[rootQ];            }            else{                parent[rootP]&#x3D;rootQ;                size[rootQ]+&#x3D;size[rootP];            }            Count--;        }        bool connected(int p,int q){            int rootP&#x3D;find(p);            int rootQ&#x3D;find(q);            return rootP&#x3D;&#x3D;rootQ;        }        int count(){return Count;}};class Solution {public:    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {        int row&#x3D;grid.size();        if(row&#x3D;&#x3D;0)            return 0;        int col&#x3D;grid[0].size();        if(col&#x3D;&#x3D;0)            return 0;        int n&#x3D;row*col;        UnionFind AA(n+1);        int dx[2]&#x3D;{1,0};        int dy[2]&#x3D;{0,-1};        for(int i&#x3D;0;i&lt;n;i++){            int x&#x3D;i&#x2F;col;            int y&#x3D;i%col;            if(grid[x][y]&#x3D;&#x3D;&#39;1&#39;){                for(int j&#x3D;0;j&lt;2;j++){                    int xx&#x3D;x+dx[j];                    int yy&#x3D;y+dy[j];                    if(xx&gt;&#x3D;0&amp;&amp;xx&lt;row&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;col&amp;&amp;grid[xx][yy]&#x3D;&#x3D;&#39;1&#39;){                        AA.Union(i,yy+xx*col);                    }                }            }            else{                AA.Union(i,n);            }        }        return AA.count()-1;      }};</code></pre><p>还有DFS和BFS的方法&gt;&gt;&gt;&gt;&gt;&gt;</p>]]></content>
    
    
    
    <tags>
      
      <tag>Breadth First Search</tag>
      
      <tag>Depth First Search</tag>
      
      <tag>Union Find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长上升子序列</title>
    <link href="/2020/03/14/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2020/03/14/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>难以置信的二分法</p><a id="more"></a><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p><p>说明:</p><pre><code>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。</code></pre><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><p>来源：力扣（LeetCode）每日一题Day14</p></blockquote><h3 id="反正我是只会DP的渣😂"><a href="#反正我是只会DP的渣😂" class="headerlink" title="反正我是只会DP的渣😂"></a>反正我是只会DP的渣😂</h3><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {          int n&#x3D;nums.size();        if(n&lt;1)            return 0;        int dp[n]&#x3D;{1};        int m&#x3D;0;        for(int num:nums){            int lo&#x3D;0;            int hi&#x3D;m;            while(lo&lt;hi){                int mid&#x3D;lo+(hi-lo)&#x2F;2;                if(dp[mid]&lt;num)                    lo&#x3D;mid+1;                else                    hi&#x3D;mid;            }            dp[lo]&#x3D;num;            if(lo&#x3D;&#x3D;m)                m++;        }        return m;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打开转盘锁</title>
    <link href="/2020/03/14/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/"/>
    <url>/2020/03/14/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为  ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><p>示例 1:</p><p>输入：deadends = [“0201”,”0101”,”0102”,”1212”,”2002”], target = “0202”<br>输出：6<br>解释：<br>可能的移动序列为 “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”。<br>注意 “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” 这样的序列是不能解锁的，<br>因为当拨动到 “0102” 时这个锁就会被锁定。</p><p>示例 2:</p><p>输入: deadends = [“8888”], target = “0009”<br>输出：1<br>解释：<br>把最后一位反向旋转一次即可 “0000” -&gt; “0009”。</p><p>示例 3:</p><p>输入: deadends = [“8887”,”8889”,”8878”,”8898”,”8788”,”8988”,”7888”,”9888”], target = “8888”<br>输出：-1<br>解释：<br>无法旋转到目标数字且不被锁定。</p><p>示例 4:</p><p>输入: deadends = [“0000”], target = “8888”<br>输出：-1</p><p>提示：</p><pre><code>死亡列表 deadends 的长度范围为 [1, 500]。目标数字 target 不会在 deadends 之中。每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 &apos;0000&apos; 到 &apos;9999&apos; 中产生。</code></pre><p>来源：力扣（LeetCode）752</p></blockquote><pre><code>class Solution {public:    int openLock(vector&lt;string&gt;&amp; deadends, string target) {        unordered_set&lt;string&gt; deadset(deadends.begin(),deadends.end());        if(deadset.find(&quot;0000&quot;)!&#x3D;deadset.end())            return -1;        unordered_set&lt;string&gt; visited;        deque&lt;string&gt; temp;        visited.insert(&quot;0000&quot;);        temp.push_back(&quot;0000&quot;);        int step&#x3D;0;        while(!temp.empty()){            int n&#x3D;temp.size();            for(int j&#x3D;0;j&lt;n;j++){                string s&#x3D;temp.front();                temp.pop_front();                if(s&#x3D;&#x3D;target)                    return step;                                for(int i&#x3D;0;i&lt;4;i++){                    string s1,s2;                    s1&#x3D;s;s2&#x3D;s;                    s1[i]&#x3D;(s1[i]&#x3D;&#x3D;&#39;0&#39;)?&#39;9&#39;:s1[i]-1;                    s2[i]&#x3D;(s2[i]&#x3D;&#x3D;&#39;9&#39;)?&#39;0&#39;:s2[i]+1;                    if(visited.find(s1)&#x3D;&#x3D;visited.end()&amp;&amp;deadset.find(s1)&#x3D;&#x3D;deadset.end()){                        temp.push_back(s1);                        visited.insert(s1);                    }                    if(visited.find(s2)&#x3D;&#x3D;visited.end()&amp;&amp;deadset.find(s2)&#x3D;&#x3D;deadset.end()){                        temp.push_back(s2);                        visited.insert(s2);                    }                }            }            step++;        }        return -1;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Breadth First Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复原IP地址</title>
    <link href="/2020/03/14/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <url>/2020/03/14/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p> 此题边界条件有很多细节<br> <a id="more"></a></p><blockquote><p>IP地址的范围是0~255，这个0的存在就很emm<br>比如一个测试用例&gt;”010010”<br>0这里是不可以前置于一个整数前的!010，001这种是不允许的</p></blockquote><blockquote><p>标准回溯法：<br>    从一个起点开始，向可行的所有分支中尝试，并将可行的加入解集，如果发现不符合，立刻删除回到上一步重新选择。<br>    这里的pruning条件是当前的IP取完后，后面剩余的字符串长度是否可以支持后续的IP地址选取。<br>    depth代表你取了几个IP地址，例如depth=2，剩余字符串长度却有7，此时就发生了上溢，因此需要跳过这种情况，就有了<br>        s.length()-1-right&gt;3<em>(4-depth) 3为每一位IP最长的可能数字<br>    同理，下溢时，会有<br>        s.length()-1-right&lt;1</em>(4-depth)<br>    对于符合条件的子串，将它转为数字，判断是否合法(0-255)<br>    然后再接在结果串的末尾+”.”<br>    递归(深度搜索)，直到depth==4<br>    还有一点就是对前导0的判断，含有前导0的分支应立刻删去！</p></blockquote><pre><code>class Solution {public:    vector&lt;string&gt; restoreIpAddresses(string s) {        vector&lt;string&gt; res;        backtrack(0,1,res,s,&quot;&quot;);        return res;    }    void backtrack(int left,int depth,vector&lt;string&gt;&amp; res,string &amp;s,string temp){        if(left&gt;&#x3D;s.length())            return;        for(int right&#x3D;left;right&lt;s.length()&amp;&amp;right&lt;&#x3D;left+2;right++){            if(s.length()-right-1&gt;3*(4-depth))    continue;            if(s.length()-right-1&lt;1*(4-depth))    continue;            char t[4];            int i&#x3D;0;            for(;i&lt;&#x3D;right-left;i++){                t[i]&#x3D;s[left+i];            }            t[i]&#x3D;&#39;\0&#39;;            if(is_ip(t)){                if(depth&#x3D;&#x3D;4){                    temp+&#x3D;t;                    res.push_back(temp);                    return;                }                backtrack(right+1,depth+1,res,s,temp+t+&quot;.&quot;);            }        }    }    bool is_ip(const char s[]){        if(s[0]&#x3D;&#x3D;&#39;0&#39;&amp;&amp;s[1]!&#x3D;&#39;\0&#39;)            return false;        int a;        sscanf(s,&quot;%d&quot;,&amp;a);        if(a&gt;&#x3D;0&amp;&amp;a&lt;256)            return true;        else            return false;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Backtrack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CountCompleteTreeNodes</title>
    <link href="/2020/03/13/CountCompleteTreeNodes/"/>
    <url>/2020/03/13/CountCompleteTreeNodes/</url>
    
    <content type="html"><![CDATA[<pre><code>&#x2F;** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; *&#x2F;class Solution {public:    int countNodes(TreeNode* root) {        if(!root)            return 0;        int left&#x3D;level(root-&gt;left);        int right&#x3D;level(root-&gt;right);        if(left&#x3D;&#x3D;right){            return countNodes(root-&gt;right)+(1&lt;&lt;left);        }        else{            return countNodes(root-&gt;left)+(1&lt;&lt;right);        }    }    int level(TreeNode* root){        int level&#x3D;0;        while(root){            root&#x3D;root-&gt;left;            level++;        }        return level;    }};</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreePaths</title>
    <link href="/2020/03/13/BinaryTreePaths/"/>
    <url>/2020/03/13/BinaryTreePaths/</url>
    
    <content type="html"><![CDATA[<pre><code>&#x2F;** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; *&#x2F;class Solution {public:    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {        if(!root)            return {};        vector&lt;string&gt; res;        Path(root,res,&quot;&quot;);        return res;      }    void Path(TreeNode* root,vector&lt;string&gt;&amp; res,string path){        path+&#x3D;to_string(root-&gt;val);        if(!root-&gt;left&amp;&amp;!root-&gt;right){            res.push_back(path);            return;        }              if(root-&gt;left)            Path(root-&gt;left,res,path+&quot;-&gt;&quot;);        if(root-&gt;right)            Path(root-&gt;right,res,path+&quot;-&gt;&quot;);    }};</code></pre><p>不递归这就绝对不是简单的问题了(说到底还是自己太vegetable)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MajorityElement</title>
    <link href="/2020/03/13/MajorityElement/"/>
    <url>/2020/03/13/MajorityElement/</url>
    
    <content type="html"><![CDATA[<pre><code>class Solution {public:    int majorityElement(vector&lt;int&gt;&amp; nums) {        int n&#x3D;nums.size();        int count&#x3D;0;        int temp&#x3D;0;        for(int i&#x3D;0;i&lt;n;i++){            if(count&#x3D;&#x3D;0){                temp&#x3D;nums[i];                count++;            }            else{                nums[i]&#x3D;&#x3D;temp?count++:count--;            }        }        return temp;    }};</code></pre><pre><code>class Solution {public:    int majorityElement(vector&lt;int&gt;&amp; nums) {        int n&#x3D;nums.size();        int res&#x3D;0;        for(int i&#x3D;0;i&lt;32;i++){            int one&#x3D;0,zero&#x3D;0;            for(int j&#x3D;0;j&lt;n;j++){                if(one&gt;n&#x2F;2||zero&gt;n&#x2F;2)   break;                if((nums[j]&amp;(1&lt;&lt;i))!&#x3D;0)   one++;                else   zero++;               }            if(one&gt;zero)                res&#x3D;res|(1&lt;&lt;i);        }        return res;    }};</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Reverse Nodes in k-Group</title>
    <link href="/2020/03/12/LC-25/"/>
    <url>/2020/03/12/LC-25/</url>
    
    <content type="html"><![CDATA[<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>Example:</p><p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>Note:</p><pre><code>Only constant extra memory is allowed.You may not alter the values in the list&#39;s nodes, only nodes itself may be changed.</code></pre><pre><code>&#x2F;** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; *&#x2F;class Solution {public:    ListNode* reverseKGroup(ListNode* head, int k) {        ListNode* dummy&#x3D;new ListNode(0);        ListNode* prev&#x3D;dummy;        dummy-&gt;next&#x3D;head;        ListNode* curr&#x3D;head;        ListNode* temp;        int len&#x3D;0;        while(head){            len++;            head&#x3D;head-&gt;next;        }        head&#x3D;dummy-&gt;next;        for(int i&#x3D;0;i&lt;len&#x2F;k;i++){            for(int j&#x3D;0;j&lt;k-1;j++){                temp&#x3D;curr-&gt;next;                curr-&gt;next&#x3D;temp-&gt;next;                temp-&gt;next&#x3D;prev-&gt;next;                prev-&gt;next&#x3D;temp;            }            prev&#x3D;curr;            curr&#x3D;prev-&gt;next;        }        return dummy-&gt;next;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linked List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode1071</title>
    <link href="/2020/03/12/LeetCode1071/"/>
    <url>/2020/03/12/LeetCode1071/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/12/LeetCode1071/t.png" srcset="/img/loading.gif" alt="1071"></p><blockquote><p>greatest common divisor<br>最大公因数与辗转相除法<br>    gcd(a,b)=gcd(b,a%b)<br>证明：设a=kb+r, r=a%b<br>    设d=gcd(a,b), d|a,d|b;<br>    r=a-kb; r/d=a/d-k*b/d;<br>    所以r/d也是一个整数，d|r<br>    所以gcd(a,b)=gcd(b.a%b).<br>    同样的，对于一个字符串的长度而言，可以先找到它们的公因数长度的子串，如果存在这样一个子串，那么它的长度必然等于原字符串中的任一个最小因子长度的子字符串。<br>    注意每次都要先进行条件判断，即它们是否同构</p></blockquote><pre><code>class Solution {public:    inline int gcd(int a,int b){return b&#x3D;&#x3D;0?a:gcd(b,a%b);}    string gcdOfStrings(string str1, string str2) {        if(str1+str2!&#x3D;str2+str1)    return&quot;&quot;;        return str1.substr(0,gcd(str1.size(),str2.size()));    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Combination</title>
    <link href="/2020/03/11/Combination/"/>
    <url>/2020/03/11/Combination/</url>
    
    <content type="html"><![CDATA[<h3 id="215-Combination-Sum-III"><a href="#215-Combination-Sum-III" class="headerlink" title="215.Combination Sum III"></a>215.Combination Sum III</h3><p>先上代码233：</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {        vector&lt;vector&lt;int&gt;&gt; res;        vector&lt;int&gt; path;        backtrack(n,path,k,res,0);        return res;    }    void backtrack(int n,vector&lt;int&gt;&amp; path,int k,vector&lt;vector&lt;int&gt;&gt;&amp; res,int start){        if(n&lt;0)            return;        if(k&#x3D;&#x3D;0){            if(n&#x3D;&#x3D;0)                res.push_back(path);            return;        }        for(int i&#x3D;start;i&lt;9;i++){            path.push_back(i+1);            backtrack(n-(i+1),path,k-1,res,i+1);            path.pop_back();        }    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Backtrack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>findKth</title>
    <link href="/2020/03/11/findKth/"/>
    <url>/2020/03/11/findKth/</url>
    
    <content type="html"><![CDATA[<h3 id="215-寻找第K大的元素"><a href="#215-寻找第K大的元素" class="headerlink" title="215.寻找第K大的元素"></a>215.寻找第K大的元素</h3><p><img src="/2020/03/11/findKth/find.png" srcset="/img/loading.gif" alt="txt"></p><pre><code>class Solution {public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {        int n&#x3D;nums.size();        return findKth(nums,0,n-1,k);    }    int findKth(vector&lt;int&gt; &amp;nums,int left,int right,int k){        int index&#x3D;partition(nums,left,right);        if(index+1&#x3D;&#x3D;k)            return nums[index];        else if(index+1&lt;k)            return findKth(nums,index+1,right,k);        else if(index+1&gt;k)            return findKth(nums,left,index-1,k);        else            return -1;    }    int partition(vector&lt;int&gt;&amp; nums,int left,int right){        int pivot&#x3D;rand()%(right-left+1)+left;        swap(nums[left],nums[pivot]);        int temp&#x3D;nums[left];        int i&#x3D;left;        int j&#x3D;left+1;        while(j&lt;&#x3D;right){            if(nums[j]&gt;&#x3D;temp)                swap(nums[j],nums[++i]);            j++;        }        swap(nums[left],nums[i]);        return i;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
      <tag>Sorting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-207</title>
    <link href="/2020/03/10/LeetCode-207/"/>
    <url>/2020/03/10/LeetCode-207/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/10/LeetCode-207/LeetCode-207%5Ctest.png" srcset="/img/loading.gif" alt="207"></p><h3 id="如何理解这样一个问题"><a href="#如何理解这样一个问题" class="headerlink" title="如何理解这样一个问题"></a>如何理解这样一个问题</h3><blockquote><p>课程1是课程0的前期必修课程，所以存在1-&gt;0这样的一种映射关系<br>那么根据课程表里的信息，我们可以相应的建立这样一张课程图。<br>图中每一个顶点可能没有入度(因为没有前期必修的课程基础)，<br>这样的一系列节点自然符合课程的修读要求，是自然符合的。那么，我们只需要关系那些存在入度的顶点，观察它们再现有的条件下，是否能够满足，如果全部都满足了，那么就是有效的课程，反之则无效。</p></blockquote><h3 id="第一种策略：广度优先搜索"><a href="#第一种策略：广度优先搜索" class="headerlink" title="第一种策略：广度优先搜索"></a>第一种策略：广度优先搜索</h3><pre><code>class Solution {public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {        map&lt;int,set&lt;int&gt;&gt; adjacent;        vector&lt;int&gt; indegree(numCourses);        for(auto&amp; p:prerequisites){            adjacent[p[1]].insert(p[0]);            indegree[p[0]]++;        }        queue&lt;int&gt; todo;        for(int i&#x3D;0;i&lt;numCourses;i++){            if(!indegree[i])                todo.push(i);&#x2F;&#x2F;        }        int count&#x3D;0;        while(!todo.empty()){            auto vertex&#x3D;todo.front();            todo.pop();            auto t&#x3D;adjacent[vertex];            for(auto x:t){                --indegree[x];                if(!indegree[x])                        todo.push(x);            }            count++;        }        return count&#x3D;&#x3D;numCourses;    }};</code></pre><blockquote><p>每一次操作时，先扣除与目前访问顶点相连的邻居们的入度，然后对于每一个入度为0的顶点的所有邻居进行遍历并将它们入队，完成一次操作，将完成的课程数count++，最后再与课程总数进行比较。</p></blockquote><h3 id="第二种策略-深度优先搜索"><a href="#第二种策略-深度优先搜索" class="headerlink" title="第二种策略: 深度优先搜索"></a>第二种策略: 深度优先搜索</h3><pre><code>class Solution {public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {        map&lt;int,set&lt;int&gt;&gt; adjacent;        vector&lt;int&gt; outdegree(numCourses);        for(auto&amp; p:prerequisites){            adjacent[p[0]].insert(p[1]);            outdegree[p[1]]++;        }        stack&lt;int&gt; todo;        for(int i&#x3D;0;i&lt;numCourses;i++){            if(!outdegree[i])                todo.push(i);&#x2F;&#x2F;        }        int count&#x3D;0;        while(!todo.empty()){            auto vertex&#x3D;todo.top();            todo.pop();            auto t&#x3D;adjacent[vertex];            for(auto x:t){                --outdegree[x];                if(!outdegree[x])                        todo.push(x);            }            count++;        }        return count&#x3D;&#x3D;numCourses;    }};</code></pre><blockquote><p>与第一种方法正好相反，我们对顶点的出度进行讨论。顶点出度为0的那些，作为深度优先搜索，应该是最后达到但是最先完成访问的那些末端，我们假设访问到了这样一个顶点，代表了我们修读完了一门课程，接下来我们去寻找能够访问到这个顶点的前驱们，注意先要将这些前驱们的出度进行修改。如果发现前驱们的出度也变为0，则我们就找到了这样一种前后对应关系的课程，反复操作直至栈空。注意如果存在环形结构，它们顶点的出度必然不为0，同时也不可能在合法访问后发生减小，因此它们根本无法被访问到，count不可能到达原定的课程数，也就不满足条件。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Graph</tag>
      
      <tag>Breadth First Search</tag>
      
      <tag>Depth First Search</tag>
      
      <tag>Topological Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-84</title>
    <link href="/2020/03/10/LeetCode-84/"/>
    <url>/2020/03/10/LeetCode-84/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/10/LeetCode-84/aaa.jpg" srcset="/img/loading.gif" alt="aaa"></p><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        int n&#x3D;heights.size();        int m&#x3D;0;        for(int i&#x3D;0;i&lt;n;i++){            int k&#x3D;INT_MAX;            for(int j&#x3D;i;j&lt;n;j++){                k&#x3D;min(k,heights[j]);                m&#x3D;max(m,(j-i+1)*k);            }        }        return m;    }};</code></pre><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        int n&#x3D;heights.size();        int m&#x3D;0;        vector&lt;int&gt; leftMin(n,-1);        vector&lt;int&gt; rightMin(n,n);        for(int i&#x3D;1;i&lt;n;i++){            int j&#x3D;i-1;            while(j&gt;&#x3D;0&amp;&amp;heights[j]&gt;&#x3D;heights[i]){                j&#x3D;leftMin[j];            }            leftMin[i]&#x3D;j;        }        for(int i&#x3D;n-2;i&gt;&#x3D;0;i--){            int j&#x3D;i+1;            while(j&lt;n&amp;&amp;heights[j]&gt;&#x3D;heights[i]){                j&#x3D;rightMin[j];            }            rightMin[i]&#x3D;j;        }        for(int i&#x3D;0;i&lt;n;i++){            m&#x3D;max(m,heights[i]*(rightMin[i]-leftMin[i]-1));        }        return m;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-18</title>
    <link href="/2020/03/10/LeetCode-18/"/>
    <url>/2020/03/10/LeetCode-18/</url>
    
    <content type="html"><![CDATA[<p>LeetCode N数之和问题-ver 3.0</p><p>  四数之和问题：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>  注意：答案中不可以包含重复的四元组。</p><p>一点问题：如何避免重复的数字反复的加入结果集合？<br>最直接的想法是先暴力枚举出所有的可能组合，再用set去重，时间复杂度O(N^4)-&gt;O(N^3)<br>使用target-nums[i]改进循环，时间复杂度可下降至O(N^3)<br>如何去重？注意两个内部的while循环，两个if语句</p><pre><code>if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])</code></pre> <ol><li>不能颠倒两个条件的顺序</li><li>从i=1开始才有可能执行该语句，从而跳过前面的k-&gt;i中的重复元素</li></ol><pre><code>while(k&lt;l&amp;&amp;nums[k]&#x3D;&#x3D;nums[k+1])  ++k;while(k&lt;l&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1])  --l;++k;--l;&#x2F;&#x2F;注意这里，判断的边界需要再加1&#x2F;减1</code></pre><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="以下是一种解法："><a href="#以下是一种解法：" class="headerlink" title="以下是一种解法："></a>以下是一种解法：</h3><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;vector&lt;int&gt;&gt; res;        if(nums.empty())            return {};                sort(nums.begin(),nums.end());        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++){            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])  {                continue;                            }              int threeSum&#x3D;target-nums[i];            for(int j&#x3D;i+1;j&lt;n;j++){                if(j&gt;i+1&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]){                    continue;                                    }                    int twoSum&#x3D;threeSum-nums[j];                int k&#x3D;j+1;                int l&#x3D;n-1;                while(k&lt;l){                    if(nums[k]+nums[l]&#x3D;&#x3D;twoSum){                        res.push_back({nums[i],nums[j],nums[k],nums[l]});                        while(k&lt;l&amp;&amp;nums[k]&#x3D;&#x3D;nums[k+1]){                            ++k;                        }                        while(k&lt;l&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1]){                            --l;                        }                        ++k;--l;                      }                    else if(nums[k]+nums[l]&gt;twoSum){                        --l;                                            }                    else{                        ++k;                                            }                    }            }        }        return res;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Two pointers</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B-Tree dynamtic procedures/remove&amp;insert</title>
    <link href="/2020/03/09/B-Tree/"/>
    <url>/2020/03/09/B-Tree/</url>
    
    <content type="html"><![CDATA[<blockquote><p>B-树的操作：插入与删除</p></blockquote><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>首先，用查找算法找到关键码对应节点及其直接后继，类似于执行BST的删除操作，然后交换当前节点与直接后继，并将交换后的直接后继处的叶子节点删除。</p><pre><code>template&lt;typename T&gt; bool BTree&lt;T&gt;::remove(T const&amp; e){    BTNode&lt;T&gt;* v&#x3D;search(e);    if(!v)  return false;    Rank r&#x3D;v-&gt;key.search(e);    if(v-&gt;child[0]){&#x2F;&#x2F;如果v不是叶子节点，必然存在直接后继        BTNode&lt;T&gt;* u&#x3D;v-&gt;child[r+1];        while(u-&gt;child[0])  u&#x3D;u-&gt;child[0];        v-&gt;key[r]&#x3D;u-&gt;key[0];        v-&gt;key.remove(r);        v-&gt;child.remove(r+1);        _size--;    }    solveUnderFlow(v);&#x2F;&#x2F;处理由于删除发生的下溢问题    return true;       }</code></pre><h3 id="下溢问题"><a href="#下溢问题" class="headerlink" title="下溢问题"></a>下溢问题</h3><p>三种可能：左侧足够多，右侧足够多，左右都即将下溢</p><pre><code>template&lt;typename T&gt; void BTree&lt;T&gt;::solveUnderFlow(BTNode&lt;T&gt;* v){    if((_order+1)&#x2F;2&lt;&#x3D;v-&gt;child-&gt;size())&#x2F;&#x2F;没有发生下溢，不需要变化        return;    BTNode&lt;T&gt;* p&#x3D;v-&gt;parent;    if(!p){        if(!v-&gt;key.size()&amp;&amp;v-&gt;child[0]){            _root&#x3D;v-&gt;child[0];            _root-&gt;parent&#x3D;NULL;            v-&gt;child[0]&#x3D;NULL;            release(v);        }&#x2F;&#x2F;树根v没有关键码，却有唯一的非空孩子        &#x2F;&#x2F;则可以销毁掉这个节点，并将整树高度下降一个单位               return;    }    Rank r&#x3D;0;    while(p-&gt;child[r]!&#x3D;v)   r++;    &#x2F;&#x2F;确定v是p的第r个孩子，此时由于v可能不含关键码    &#x2F;&#x2F;所以不能直接通过关键码查找v    &#x2F;&#x2F;情况1：向左兄弟借关键码    if(r&gt;0){&#x2F;&#x2F;v不是p的第一个孩子        BTNode&lt;T&gt;* ls&#x3D;p-&gt;child[r-1];&#x2F;&#x2F;想想中序遍历的直接后继        if((_order+1)&#x2F;2&lt;ls-&gt;child.size()){&#x2F;&#x2F;左兄弟够借            v-&gt;key.insert(0,p-&gt;key[r-1]);&#x2F;&#x2F;先从父亲借1个            p-&gt;key[r-1]&#x3D;ls-&gt;key.remove(ls-&gt;key.size()-1);&#x2F;&#x2F;左兄弟移给父亲            v-&gt;child.insert(0,ls-&gt;child.remove(ls-&gt;child.size()-1));&#x2F;&#x2F;引用节点也要相应的转移给右边的兄弟        }        if(v-&gt;child[0]) v-&gt;child[0]-&gt;parent&#x3D;v;        &#x2F;&#x2F;移完了记得更新parent引用        return;    }    &#x2F;&#x2F;至此，左兄弟要么为空，要么不够借    &#x2F;&#x2F;情况2：向右兄弟借关键码    if(r&lt;p-&gt;child.size()){        BTNode&lt;T&gt;* rs&#x3D;p-&gt;child[r+1];        if((_order+1)&#x2F;2&lt;rs-&gt;child.size()){            v-&gt;key.insert(v-&gt;key.size(),p-&gt;key[r]);&#x2F;&#x2F;从父亲借一个，插入左边最右侧            p-&gt;key[r]&#x3D;rs-&gt;key.remove(0);            v-&gt;child.insert(v-&gt;child.size(),rs-&gt;child.remove(0));        }        if(v-&gt;child[v-&gt;child.size()-1])            v-&gt;child[v-&gt;child.size()-1]-&gt;parent&#x3D;v;       }    &#x2F;&#x2F;至此，右兄弟要么为空，要么不够借    &#x2F;&#x2F;情况3，左右兄弟要么其一为空，要么都不够借    if(r&gt;0){&#x2F;&#x2F;向左兄弟合并        BTNode&lt;T&gt;* ls&#x3D;p-&gt;child[r-1];        ls-&gt;key.insert(ls-&gt;key.size(),p-&gt;key.remove(r-1));        p-&gt;child.remove(r);&#x2F;&#x2F;将p的第r-1个关键码转入ls        ls-&gt;child.insert(ls-&gt;child.size(),v-&gt;child.remove(0));        if(ls-&gt;child[ls-&gt;child.size()-1])            ls-&gt;child[ls-&gt;child.size()-1]-&gt;parent&#x3D;ls;        while(!v-&gt;key.empty()){            ls-&gt;key.insert(ls-&gt;key.size(),v-&gt;key.remove(0));            ls-&gt;child.insert(ls-&gt;child.size(),v-&gt;child.remove(0));            if(ls-&gt;child[ls-&gt;child.size()-1])                ls-&gt;child[ls-&gt;child.size()-1]-&gt;parent&#x3D;ls;        }        release(v);    }    else{&#x2F;&#x2F;向右兄弟合并        BTNode&lt;T&gt;* rs&#x3D;p-&gt;child[r+1];        rs-&gt;key.insert(0,p-&gt;key.remove(r));        p-&gt;child.remove(r);        rs-&gt;child.insert(0,v-&gt;child.remove(v-&gt;child.size()-1));        if(rs-&gt;child[0])            rs-&gt;child[0]-&gt;parent&#x3D;rs;        while(!v-&gt;key.empty()){            rs-&gt;key.insert(0,v-&gt;key.remove(v-&gt;key.size()-1));            rs-&gt;child.insert(0,v-&gt;key.remove(v-child.size()-1));            if(rs-&gt;child[0])                rs-&gt;child[0]-&gt;parent&#x3D;rs;        }        release(v);    }    solveUnderFlow(p);    return;}</code></pre><p>复杂度：平均只有常数次的操作。极端情况为O(logn)的时间复杂度。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/03/09/hello-world/"/>
    <url>/2020/03/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello!"></a>Hello!</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Reverse Nodes in k-Group</title>
    <link href="/2020/03/12/LC-25/"/>
    <url>/2020/03/12/LC-25/</url>
    
    <content type="html"><![CDATA[<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>Example:</p><p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>Note:</p><pre><code>Only constant extra memory is allowed.You may not alter the values in the list&#39;s nodes, only nodes itself may be changed.</code></pre><pre><code>&#x2F;** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; *&#x2F;class Solution {public:    ListNode* reverseKGroup(ListNode* head, int k) {        ListNode* dummy&#x3D;new ListNode(0);        ListNode* prev&#x3D;dummy;        dummy-&gt;next&#x3D;head;        ListNode* curr&#x3D;head;        ListNode* temp;        int len&#x3D;0;        while(head){            len++;            head&#x3D;head-&gt;next;        }        head&#x3D;dummy-&gt;next;        for(int i&#x3D;0;i&lt;len&#x2F;k;i++){            for(int j&#x3D;0;j&lt;k-1;j++){                temp&#x3D;curr-&gt;next;                curr-&gt;next&#x3D;temp-&gt;next;                temp-&gt;next&#x3D;prev-&gt;next;                prev-&gt;next&#x3D;temp;            }            prev&#x3D;curr;            curr&#x3D;prev-&gt;next;        }        return dummy-&gt;next;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linked List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode1071</title>
    <link href="/2020/03/12/LeetCode1071/"/>
    <url>/2020/03/12/LeetCode1071/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/12/LeetCode1071/t.png" srcset="/img/loading.gif" alt="1071"></p><blockquote><p>greatest common divisor<br>最大公因数与辗转相除法<br>    gcd(a,b)=gcd(b,a%b)<br>证明：设a=kb+r, r=a%b<br>    设d=gcd(a,b), d|a,d|b;<br>    r=a-kb; r/d=a/d-k*b/d;<br>    所以r/d也是一个整数，d|r<br>    所以gcd(a,b)=gcd(b.a%b).<br>    同样的，对于一个字符串的长度而言，可以先找到它们的公因数长度的子串，如果存在这样一个子串，那么它的长度必然等于原字符串中的任一个最小因子长度的子字符串。<br>    注意每次都要先进行条件判断，即它们是否同构</p></blockquote><pre><code>class Solution {public:    inline int gcd(int a,int b){return b&#x3D;&#x3D;0?a:gcd(b,a%b);}    string gcdOfStrings(string str1, string str2) {        if(str1+str2!&#x3D;str2+str1)    return&quot;&quot;;        return str1.substr(0,gcd(str1.size(),str2.size()));    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Combination</title>
    <link href="/2020/03/11/Combination/"/>
    <url>/2020/03/11/Combination/</url>
    
    <content type="html"><![CDATA[<h3 id="215-Combination-Sum-III"><a href="#215-Combination-Sum-III" class="headerlink" title="215.Combination Sum III"></a>215.Combination Sum III</h3><p>先上代码233：</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {        vector&lt;vector&lt;int&gt;&gt; res;        vector&lt;int&gt; path;        backtrack(n,path,k,res,0);        return res;    }    void backtrack(int n,vector&lt;int&gt;&amp; path,int k,vector&lt;vector&lt;int&gt;&gt;&amp; res,int start){        if(n&lt;0)            return;        if(k&#x3D;&#x3D;0){            if(n&#x3D;&#x3D;0)                res.push_back(path);            return;        }        for(int i&#x3D;start;i&lt;9;i++){            path.push_back(i+1);            backtrack(n-(i+1),path,k-1,res,i+1);            path.pop_back();        }    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Backtrack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>findKth</title>
    <link href="/2020/03/11/findKth/"/>
    <url>/2020/03/11/findKth/</url>
    
    <content type="html"><![CDATA[<h3 id="215-寻找第K大的元素"><a href="#215-寻找第K大的元素" class="headerlink" title="215.寻找第K大的元素"></a>215.寻找第K大的元素</h3><p><img src="/2020/03/11/findKth/find.png" srcset="/img/loading.gif" alt="txt"></p><pre><code>class Solution {public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {        int n&#x3D;nums.size();        return findKth(nums,0,n-1,k);    }    int findKth(vector&lt;int&gt; &amp;nums,int left,int right,int k){        int index&#x3D;partition(nums,left,right);        if(index+1&#x3D;&#x3D;k)            return nums[index];        else if(index+1&lt;k)            return findKth(nums,index+1,right,k);        else if(index+1&gt;k)            return findKth(nums,left,index-1,k);        else            return -1;    }    int partition(vector&lt;int&gt;&amp; nums,int left,int right){        int pivot&#x3D;rand()%(right-left+1)+left;        swap(nums[left],nums[pivot]);        int temp&#x3D;nums[left];        int i&#x3D;left;        int j&#x3D;left+1;        while(j&lt;&#x3D;right){            if(nums[j]&gt;&#x3D;temp)                swap(nums[j],nums[++i]);            j++;        }        swap(nums[left],nums[i]);        return i;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
      <tag>Sorting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-207</title>
    <link href="/2020/03/10/LeetCode-207/"/>
    <url>/2020/03/10/LeetCode-207/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/10/LeetCode-207/LeetCode-207%5Ctest.png" srcset="/img/loading.gif" alt="207"></p><h3 id="如何理解这样一个问题"><a href="#如何理解这样一个问题" class="headerlink" title="如何理解这样一个问题"></a>如何理解这样一个问题</h3><blockquote><p>课程1是课程0的前期必修课程，所以存在1-&gt;0这样的一种映射关系<br>那么根据课程表里的信息，我们可以相应的建立这样一张课程图。<br>图中每一个顶点可能没有入度(因为没有前期必修的课程基础)，<br>这样的一系列节点自然符合课程的修读要求，是自然符合的。那么，我们只需要关系那些存在入度的顶点，观察它们再现有的条件下，是否能够满足，如果全部都满足了，那么就是有效的课程，反之则无效。</p></blockquote><h3 id="第一种策略：广度优先搜索"><a href="#第一种策略：广度优先搜索" class="headerlink" title="第一种策略：广度优先搜索"></a>第一种策略：广度优先搜索</h3><pre><code>class Solution {public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {        map&lt;int,set&lt;int&gt;&gt; adjacent;        vector&lt;int&gt; indegree(numCourses);        for(auto&amp; p:prerequisites){            adjacent[p[1]].insert(p[0]);            indegree[p[0]]++;        }        queue&lt;int&gt; todo;        for(int i&#x3D;0;i&lt;numCourses;i++){            if(!indegree[i])                todo.push(i);&#x2F;&#x2F;        }        int count&#x3D;0;        while(!todo.empty()){            auto vertex&#x3D;todo.front();            todo.pop();            auto t&#x3D;adjacent[vertex];            for(auto x:t){                --indegree[x];                if(!indegree[x])                        todo.push(x);            }            count++;        }        return count&#x3D;&#x3D;numCourses;    }};</code></pre><blockquote><p>每一次操作时，先扣除与目前访问顶点相连的邻居们的入度，然后对于每一个入度为0的顶点的所有邻居进行遍历并将它们入队，完成一次操作，将完成的课程数count++，最后再与课程总数进行比较。</p></blockquote><h3 id="第二种策略-深度优先搜索"><a href="#第二种策略-深度优先搜索" class="headerlink" title="第二种策略: 深度优先搜索"></a>第二种策略: 深度优先搜索</h3><pre><code>class Solution {public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {        map&lt;int,set&lt;int&gt;&gt; adjacent;        vector&lt;int&gt; outdegree(numCourses);        for(auto&amp; p:prerequisites){            adjacent[p[0]].insert(p[1]);            outdegree[p[1]]++;        }        stack&lt;int&gt; todo;        for(int i&#x3D;0;i&lt;numCourses;i++){            if(!outdegree[i])                todo.push(i);&#x2F;&#x2F;        }        int count&#x3D;0;        while(!todo.empty()){            auto vertex&#x3D;todo.top();            todo.pop();            auto t&#x3D;adjacent[vertex];            for(auto x:t){                --outdegree[x];                if(!outdegree[x])                        todo.push(x);            }            count++;        }        return count&#x3D;&#x3D;numCourses;    }};</code></pre><blockquote><p>与第一种方法正好相反，我们对顶点的出度进行讨论。顶点出度为0的那些，作为深度优先搜索，应该是最后达到但是最先完成访问的那些末端，我们假设访问到了这样一个顶点，代表了我们修读完了一门课程，接下来我们去寻找能够访问到这个顶点的前驱们，注意先要将这些前驱们的出度进行修改。如果发现前驱们的出度也变为0，则我们就找到了这样一种前后对应关系的课程，反复操作直至栈空。注意如果存在环形结构，它们顶点的出度必然不为0，同时也不可能在合法访问后发生减小，因此它们根本无法被访问到，count不可能到达原定的课程数，也就不满足条件。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Graph</tag>
      
      <tag>Breadth First Search</tag>
      
      <tag>Depth First Search</tag>
      
      <tag>Topological Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-84</title>
    <link href="/2020/03/10/LeetCode-84/"/>
    <url>/2020/03/10/LeetCode-84/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/10/LeetCode-84/aaa.jpg" srcset="/img/loading.gif" alt="aaa"></p><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        int n&#x3D;heights.size();        int m&#x3D;0;        for(int i&#x3D;0;i&lt;n;i++){            int k&#x3D;INT_MAX;            for(int j&#x3D;i;j&lt;n;j++){                k&#x3D;min(k,heights[j]);                m&#x3D;max(m,(j-i+1)*k);            }        }        return m;    }};</code></pre><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        int n&#x3D;heights.size();        int m&#x3D;0;        vector&lt;int&gt; leftMin(n,-1);        vector&lt;int&gt; rightMin(n,n);        for(int i&#x3D;1;i&lt;n;i++){            int j&#x3D;i-1;            while(j&gt;&#x3D;0&amp;&amp;heights[j]&gt;&#x3D;heights[i]){                j&#x3D;leftMin[j];            }            leftMin[i]&#x3D;j;        }        for(int i&#x3D;n-2;i&gt;&#x3D;0;i--){            int j&#x3D;i+1;            while(j&lt;n&amp;&amp;heights[j]&gt;&#x3D;heights[i]){                j&#x3D;rightMin[j];            }            rightMin[i]&#x3D;j;        }        for(int i&#x3D;0;i&lt;n;i++){            m&#x3D;max(m,heights[i]*(rightMin[i]-leftMin[i]-1));        }        return m;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-18</title>
    <link href="/2020/03/10/LeetCode-18/"/>
    <url>/2020/03/10/LeetCode-18/</url>
    
    <content type="html"><![CDATA[<p>LeetCode N数之和问题-ver 3.0</p><p>  四数之和问题：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>  注意：答案中不可以包含重复的四元组。</p><p>一点问题：如何避免重复的数字反复的加入结果集合？<br>最直接的想法是先暴力枚举出所有的可能组合，再用set去重，时间复杂度O(N^4)-&gt;O(N^3)<br>使用target-nums[i]改进循环，时间复杂度可下降至O(N^3)<br>如何去重？注意两个内部的while循环，两个if语句</p><pre><code>if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])</code></pre> <ol><li>不能颠倒两个条件的顺序</li><li>从i=1开始才有可能执行该语句，从而跳过前面的k-&gt;i中的重复元素</li></ol><pre><code>while(k&lt;l&amp;&amp;nums[k]&#x3D;&#x3D;nums[k+1])  ++k;while(k&lt;l&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1])  --l;++k;--l;&#x2F;&#x2F;注意这里，判断的边界需要再加1&#x2F;减1</code></pre><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="以下是一种解法："><a href="#以下是一种解法：" class="headerlink" title="以下是一种解法："></a>以下是一种解法：</h3><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;vector&lt;int&gt;&gt; res;        if(nums.empty())            return {};                sort(nums.begin(),nums.end());        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++){            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])  {                continue;                            }              int threeSum&#x3D;target-nums[i];            for(int j&#x3D;i+1;j&lt;n;j++){                if(j&gt;i+1&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]){                    continue;                                    }                    int twoSum&#x3D;threeSum-nums[j];                int k&#x3D;j+1;                int l&#x3D;n-1;                while(k&lt;l){                    if(nums[k]+nums[l]&#x3D;&#x3D;twoSum){                        res.push_back({nums[i],nums[j],nums[k],nums[l]});                        while(k&lt;l&amp;&amp;nums[k]&#x3D;&#x3D;nums[k+1]){                            ++k;                        }                        while(k&lt;l&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1]){                            --l;                        }                        ++k;--l;                      }                    else if(nums[k]+nums[l]&gt;twoSum){                        --l;                                            }                    else{                        ++k;                                            }                    }            }        }        return res;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
      <tag>Two pointers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B-Tree dynamtic procedures/remove&amp;insert</title>
    <link href="/2020/03/09/B-Tree/"/>
    <url>/2020/03/09/B-Tree/</url>
    
    <content type="html"><![CDATA[<blockquote><p>B-树的操作：插入与删除</p></blockquote><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>首先，用查找算法找到关键码对应节点及其直接后继，类似于执行BST的删除操作，然后交换当前节点与直接后继，并将交换后的直接后继处的叶子节点删除。</p><pre><code>template&lt;typename T&gt; bool BTree&lt;T&gt;::remove(T const&amp; e){    BTNode&lt;T&gt;* v&#x3D;search(e);    if(!v)  return false;    Rank r&#x3D;v-&gt;key.search(e);    if(v-&gt;child[0]){&#x2F;&#x2F;如果v不是叶子节点，必然存在直接后继        BTNode&lt;T&gt;* u&#x3D;v-&gt;child[r+1];        while(u-&gt;child[0])  u&#x3D;u-&gt;child[0];        v-&gt;key[r]&#x3D;u-&gt;key[0];        v-&gt;key.remove(r);        v-&gt;child.remove(r+1);        _size--;    }    solveUnderFlow(v);&#x2F;&#x2F;处理由于删除发生的下溢问题    return true;       }</code></pre><h3 id="下溢问题"><a href="#下溢问题" class="headerlink" title="下溢问题"></a>下溢问题</h3><p>三种可能：左侧足够多，右侧足够多，左右都即将下溢</p><pre><code>template&lt;typename T&gt; void BTree&lt;T&gt;::solveUnderFlow(BTNode&lt;T&gt;* v){    if((_order+1)&#x2F;2&lt;&#x3D;v-&gt;child-&gt;size())&#x2F;&#x2F;没有发生下溢，不需要变化        return;    BTNode&lt;T&gt;* p&#x3D;v-&gt;parent;    if(!p){        if(!v-&gt;key.size()&amp;&amp;v-&gt;child[0]){            _root&#x3D;v-&gt;child[0];            _root-&gt;parent&#x3D;NULL;            v-&gt;child[0]&#x3D;NULL;            release(v);        }&#x2F;&#x2F;树根v没有关键码，却有唯一的非空孩子        &#x2F;&#x2F;则可以销毁掉这个节点，并将整树高度下降一个单位               return;    }    Rank r&#x3D;0;    while(p-&gt;child[r]!&#x3D;v)   r++;    &#x2F;&#x2F;确定v是p的第r个孩子，此时由于v可能不含关键码    &#x2F;&#x2F;所以不能直接通过关键码查找v    &#x2F;&#x2F;情况1：向左兄弟借关键码    if(r&gt;0){&#x2F;&#x2F;v不是p的第一个孩子        BTNode&lt;T&gt;* ls&#x3D;p-&gt;child[r-1];&#x2F;&#x2F;想想中序遍历的直接后继        if((_order+1)&#x2F;2&lt;ls-&gt;child.size()){&#x2F;&#x2F;左兄弟够借            v-&gt;key.insert(0,p-&gt;key[r-1]);&#x2F;&#x2F;先从父亲借1个            p-&gt;key[r-1]&#x3D;ls-&gt;key.remove(ls-&gt;key.size()-1);&#x2F;&#x2F;左兄弟移给父亲            v-&gt;child.insert(0,ls-&gt;child.remove(ls-&gt;child.size()-1));&#x2F;&#x2F;引用节点也要相应的转移给右边的兄弟        }        if(v-&gt;child[0]) v-&gt;child[0]-&gt;parent&#x3D;v;        &#x2F;&#x2F;移完了记得更新parent引用        return;    }    &#x2F;&#x2F;至此，左兄弟要么为空，要么不够借    &#x2F;&#x2F;情况2：向右兄弟借关键码    if(r&lt;p-&gt;child.size()){        BTNode&lt;T&gt;* rs&#x3D;p-&gt;child[r+1];        if((_order+1)&#x2F;2&lt;rs-&gt;child.size()){            v-&gt;key.insert(v-&gt;key.size(),p-&gt;key[r]);&#x2F;&#x2F;从父亲借一个，插入左边最右侧            p-&gt;key[r]&#x3D;rs-&gt;key.remove(0);            v-&gt;child.insert(v-&gt;child.size(),rs-&gt;child.remove(0));        }        if(v-&gt;child[v-&gt;child.size()-1])            v-&gt;child[v-&gt;child.size()-1]-&gt;parent&#x3D;v;       }    &#x2F;&#x2F;至此，右兄弟要么为空，要么不够借    &#x2F;&#x2F;情况3，左右兄弟要么其一为空，要么都不够借    if(r&gt;0){&#x2F;&#x2F;向左兄弟合并        BTNode&lt;T&gt;* ls&#x3D;p-&gt;child[r-1];        ls-&gt;key.insert(ls-&gt;key.size(),p-&gt;key.remove(r-1));        p-&gt;child.remove(r);&#x2F;&#x2F;将p的第r-1个关键码转入ls        ls-&gt;child.insert(ls-&gt;child.size(),v-&gt;child.remove(0));        if(ls-&gt;child[ls-&gt;child.size()-1])            ls-&gt;child[ls-&gt;child.size()-1]-&gt;parent&#x3D;ls;        while(!v-&gt;key.empty()){            ls-&gt;key.insert(ls-&gt;key.size(),v-&gt;key.remove(0));            ls-&gt;child.insert(ls-&gt;child.size(),v-&gt;child.remove(0));            if(ls-&gt;child[ls-&gt;child.size()-1])                ls-&gt;child[ls-&gt;child.size()-1]-&gt;parent&#x3D;ls;        }        release(v);    }    else{&#x2F;&#x2F;向右兄弟合并        BTNode&lt;T&gt;* rs&#x3D;p-&gt;child[r+1];        rs-&gt;key.insert(0,p-&gt;key.remove(r));        p-&gt;child.remove(r);        rs-&gt;child.insert(0,v-&gt;child.remove(v-&gt;child.size()-1));        if(rs-&gt;child[0])            rs-&gt;child[0]-&gt;parent&#x3D;rs;        while(!v-&gt;key.empty()){            rs-&gt;key.insert(0,v-&gt;key.remove(v-&gt;key.size()-1));            rs-&gt;child.insert(0,v-&gt;key.remove(v-child.size()-1));            if(rs-&gt;child[0])                rs-&gt;child[0]-&gt;parent&#x3D;rs;        }        release(v);    }    solveUnderFlow(p);    return;}</code></pre><p>复杂度：平均只有常数次的操作。极端情况为O(logn)的时间复杂度。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/03/09/hello-world/"/>
    <url>/2020/03/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello!"></a>Hello!</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

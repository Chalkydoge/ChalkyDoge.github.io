<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Combination</title>
    <link href="/2020/03/11/Combination/"/>
    <url>/2020/03/11/Combination/</url>
    
    <content type="html"><![CDATA[<h3 id="215-Combination-Sum-III"><a href="#215-Combination-Sum-III" class="headerlink" title="215.Combination Sum III"></a>215.Combination Sum III</h3><p>先上代码233：</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {        vector&lt;vector&lt;int&gt;&gt; res;        vector&lt;int&gt; path;        backtrack(n,path,k,res,0);        return res;    }    void backtrack(int n,vector&lt;int&gt;&amp; path,int k,vector&lt;vector&lt;int&gt;&gt;&amp; res,int start){        if(n&lt;0)            return;        if(k&#x3D;&#x3D;0){            if(n&#x3D;&#x3D;0)                res.push_back(path);            return;        }        for(int i&#x3D;start;i&lt;9;i++){            path.push_back(i+1);            backtrack(n-(i+1),path,k-1,res,i+1);            path.pop_back();        }    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Backtrack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>findKth</title>
    <link href="/2020/03/11/findKth/"/>
    <url>/2020/03/11/findKth/</url>
    
    <content type="html"><![CDATA[<h3 id="215-寻找第K大的元素"><a href="#215-寻找第K大的元素" class="headerlink" title="215.寻找第K大的元素"></a>215.寻找第K大的元素</h3><p><img src="/2020/03/11/findKth/%5CfindKth%5Cfind.png" srcset="/img/loading.gif" alt="txt"></p><pre><code>class Solution {public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {        int n&#x3D;nums.size();        return findKth(nums,0,n-1,k);    }    int findKth(vector&lt;int&gt; &amp;nums,int left,int right,int k){        int index&#x3D;partition(nums,left,right);        if(index+1&#x3D;&#x3D;k)            return nums[index];        else if(index+1&lt;k)            return findKth(nums,index+1,right,k);        else if(index+1&gt;k)            return findKth(nums,left,index-1,k);        else            return -1;    }    int partition(vector&lt;int&gt;&amp; nums,int left,int right){        int pivot&#x3D;rand()%(right-left+1)+left;        swap(nums[left],nums[pivot]);        int temp&#x3D;nums[left];        int i&#x3D;left;        int j&#x3D;left+1;        while(j&lt;&#x3D;right){            if(nums[j]&gt;&#x3D;temp)                swap(nums[j],nums[++i]);            j++;        }        swap(nums[left],nums[i]);        return i;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
      <tag>Sorting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-207</title>
    <link href="/2020/03/10/LeetCode-207/"/>
    <url>/2020/03/10/LeetCode-207/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/10/LeetCode-207/test.png" srcset="/img/loading.gif" alt="207"></p><pre><code>class Solution {public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {        map&lt;int,set&lt;int&gt;&gt; adjacent;        vector&lt;int&gt; indegree(numCourses);        for(auto&amp; p:prerequisites){            adjacent[p[1]].insert(p[0]);            indegree[p[0]]++;        }        queue&lt;int&gt; todo;        for(int i&#x3D;0;i&lt;numCourses;i++){            if(!indegree[i])                todo.push(i);&#x2F;&#x2F;        }        int count&#x3D;0;        while(!todo.empty()){            auto vertex&#x3D;todo.front();            todo.pop();            auto t&#x3D;adjacent[vertex];            for(auto x:t){                --indegree[x];                if(!indegree[x])                        todo.push(x);            }            count++;        }        return count&#x3D;&#x3D;numCourses;    }};</code></pre><pre><code>class Solution {public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {        map&lt;int,set&lt;int&gt;&gt; adjacent;        vector&lt;int&gt; outdegree(numCourses);        for(auto&amp; p:prerequisites){            adjacent[p[0]].insert(p[1]);            outdegree[p[1]]++;        }        stack&lt;int&gt; todo;        for(int i&#x3D;0;i&lt;numCourses;i++){            if(!outdegree[i])                todo.push(i);&#x2F;&#x2F;        }        int count&#x3D;0;        while(!todo.empty()){            auto vertex&#x3D;todo.top();            todo.pop();            auto t&#x3D;adjacent[vertex];            for(auto x:t){                --outdegree[x];                if(!outdegree[x])                        todo.push(x);            }            count++;        }        return count&#x3D;&#x3D;numCourses;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Graph</tag>
      
      <tag>Breadth First Search</tag>
      
      <tag>Depth First Search</tag>
      
      <tag>Topological Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-84</title>
    <link href="/2020/03/10/LeetCode-84/"/>
    <url>/2020/03/10/LeetCode-84/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/10/LeetCode-84/aaa.jpg" srcset="/img/loading.gif" alt="aaa"></p><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        int n&#x3D;heights.size();        int m&#x3D;0;        for(int i&#x3D;0;i&lt;n;i++){            int k&#x3D;INT_MAX;            for(int j&#x3D;i;j&lt;n;j++){                k&#x3D;min(k,heights[j]);                m&#x3D;max(m,(j-i+1)*k);            }        }        return m;    }};</code></pre><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        int n&#x3D;heights.size();        int m&#x3D;0;        vector&lt;int&gt; leftMin(n,-1);        vector&lt;int&gt; rightMin(n,n);        for(int i&#x3D;1;i&lt;n;i++){            int j&#x3D;i-1;            while(j&gt;&#x3D;0&amp;&amp;heights[j]&gt;&#x3D;heights[i]){                j&#x3D;leftMin[j];            }            leftMin[i]&#x3D;j;        }        for(int i&#x3D;n-2;i&gt;&#x3D;0;i--){            int j&#x3D;i+1;            while(j&lt;n&amp;&amp;heights[j]&gt;&#x3D;heights[i]){                j&#x3D;rightMin[j];            }            rightMin[i]&#x3D;j;        }        for(int i&#x3D;0;i&lt;n;i++){            m&#x3D;max(m,heights[i]*(rightMin[i]-leftMin[i]-1));        }        return m;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-18</title>
    <link href="/2020/03/10/LeetCode-18/"/>
    <url>/2020/03/10/LeetCode-18/</url>
    
    <content type="html"><![CDATA[<p>LeetCode N数之和问题-ver 3.0</p><p>  四数之和问题：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>  注意：答案中不可以包含重复的四元组。</p><p>一点问题：如何避免重复的数字反复的加入结果集合？<br>最直接的想法是先暴力枚举出所有的可能组合，再用set去重，时间复杂度O(N^4)-&gt;O(N^3)<br>使用target-nums[i]改进循环，时间复杂度可下降至O(N^3)<br>如何去重？注意两个内部的while循环，两个if语句</p><pre><code>if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])</code></pre> <ol><li>不能颠倒两个条件的顺序</li><li>从i=1开始才有可能执行该语句，从而跳过前面的k-&gt;i中的重复元素</li></ol><pre><code>while(k&lt;l&amp;&amp;nums[k]&#x3D;&#x3D;nums[k+1])  ++k;while(k&lt;l&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1])  --l;++k;--l;&#x2F;&#x2F;注意这里，判断的边界需要再加1&#x2F;减1</code></pre><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="以下是一种解法："><a href="#以下是一种解法：" class="headerlink" title="以下是一种解法："></a>以下是一种解法：</h3><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;vector&lt;int&gt;&gt; res;        if(nums.empty())            return {};                sort(nums.begin(),nums.end());        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++){            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])  {                continue;                            }              int threeSum&#x3D;target-nums[i];            for(int j&#x3D;i+1;j&lt;n;j++){                if(j&gt;i+1&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]){                    continue;                                    }                    int twoSum&#x3D;threeSum-nums[j];                int k&#x3D;j+1;                int l&#x3D;n-1;                while(k&lt;l){                    if(nums[k]+nums[l]&#x3D;&#x3D;twoSum){                        res.push_back({nums[i],nums[j],nums[k],nums[l]});                        while(k&lt;l&amp;&amp;nums[k]&#x3D;&#x3D;nums[k+1]){                            ++k;                        }                        while(k&lt;l&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1]){                            --l;                        }                        ++k;--l;                      }                    else if(nums[k]+nums[l]&gt;twoSum){                        --l;                                            }                    else{                        ++k;                                            }                    }            }        }        return res;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Two pointers</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B-Tree dynamtic procedures/remove&amp;insert</title>
    <link href="/2020/03/09/B-Tree/"/>
    <url>/2020/03/09/B-Tree/</url>
    
    <content type="html"><![CDATA[<blockquote><p>B-树的操作：插入与删除</p></blockquote><pre><code>template&lt;typename T&gt; bool BTree&lt;T&gt;::remove(T const&amp; e){    BTNode&lt;T&gt;* v&#x3D;search(e);    if(!v)  return false;    Rank r&#x3D;v-&gt;key.search(e);    if(v-&gt;child[0]){        BTNode&lt;T&gt;* u&#x3D;v-&gt;child[r+1];        while(u-&gt;child[0])  u&#x3D;u-&gt;child[0];        v-&gt;key[r]&#x3D;u-&gt;key[0];        v-&gt;key.remove(r);        v-&gt;child.remove(r+1);        _size--;    }       }</code></pre><h3 id="AAAAAAAAA"><a href="#AAAAAAAAA" class="headerlink" title="AAAAAAAAA"></a>AAAAAAAAA</h3><h2 id="AAAAABBBBAAAA"><a href="#AAAAABBBBAAAA" class="headerlink" title="AAAAABBBBAAAA"></a>AAAAABBBBAAAA</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/03/09/hello-world/"/>
    <url>/2020/03/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello!"></a>Hello!</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

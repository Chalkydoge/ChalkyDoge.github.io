<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>_200_岛屿数量</title>
    <link href="/2020/03/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <url>/2020/03/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<pre><code>class UnionFind{    private:        int Count;        vector&lt;int&gt; parent;        vector&lt;int&gt; size;    public:        UnionFind(int n){            this-&gt;Count&#x3D;n;            for(int i&#x3D;0;i&lt;n;i++){                parent.push_back(i);                size.push_back(1);            }        }        int find(int p){            while(p!&#x3D;parent[p]){                parent[p]&#x3D;parent[parent[p]];                p&#x3D;parent[p];            }            return p;        }        void Union(int p,int q){            int rootP&#x3D;find(p);            int rootQ&#x3D;find(q);            if(connected(p,q))    return;            if(size[rootP]&gt;size[rootQ]){                parent[rootQ]&#x3D;rootP;                size[rootP]+&#x3D;size[rootQ];            }            else{                parent[rootP]&#x3D;rootQ;                size[rootQ]+&#x3D;size[rootP];            }            Count--;        }        bool connected(int p,int q){            int rootP&#x3D;find(p);            int rootQ&#x3D;find(q);            return rootP&#x3D;&#x3D;rootQ;        }        int count(){return Count;}};class Solution {public:    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {        int row&#x3D;grid.size();        if(row&#x3D;&#x3D;0)            return 0;        int col&#x3D;grid[0].size();        if(col&#x3D;&#x3D;0)            return 0;        int n&#x3D;row*col;        UnionFind AA(n+1);        int dx[2]&#x3D;{1,0};        int dy[2]&#x3D;{0,-1};        for(int i&#x3D;0;i&lt;n;i++){            int x&#x3D;i&#x2F;col;            int y&#x3D;i%col;            if(grid[x][y]&#x3D;&#x3D;&#39;1&#39;){                for(int j&#x3D;0;j&lt;2;j++){                    int xx&#x3D;x+dx[j];                    int yy&#x3D;y+dy[j];                    if(xx&gt;&#x3D;0&amp;&amp;xx&lt;row&amp;&amp;yy&gt;&#x3D;0&amp;&amp;yy&lt;col&amp;&amp;grid[xx][yy]&#x3D;&#x3D;&#39;1&#39;){                        AA.Union(i,yy+xx*col);                    }                }            }            else{                AA.Union(i,n);            }        }        return AA.count()-1;            }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Breadth First Search</tag>
      
      <tag>Depth First Search</tag>
      
      <tag>Union Find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长上升子序列</title>
    <link href="/2020/03/14/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2020/03/14/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p><p>说明:</p><pre><code>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。</code></pre><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><p>来源：力扣（LeetCode）每日一题Day14</p></blockquote><pre><code>class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {          int n&#x3D;nums.size();        if(n&lt;1)            return 0;        int dp[n]&#x3D;{1};        int m&#x3D;0;        for(int num:nums){            int lo&#x3D;0;            int hi&#x3D;m;            while(lo&lt;hi){                int mid&#x3D;lo+(hi-lo)&#x2F;2;                if(dp[mid]&lt;num)                    lo&#x3D;mid+1;                else                    hi&#x3D;mid;            }            dp[lo]&#x3D;num;            if(lo&#x3D;&#x3D;m)                m++;        }        return m;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打开转盘锁</title>
    <link href="/2020/03/14/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/"/>
    <url>/2020/03/14/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为  ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><p>示例 1:</p><p>输入：deadends = [“0201”,”0101”,”0102”,”1212”,”2002”], target = “0202”<br>输出：6<br>解释：<br>可能的移动序列为 “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”。<br>注意 “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” 这样的序列是不能解锁的，<br>因为当拨动到 “0102” 时这个锁就会被锁定。</p><p>示例 2:</p><p>输入: deadends = [“8888”], target = “0009”<br>输出：1<br>解释：<br>把最后一位反向旋转一次即可 “0000” -&gt; “0009”。</p><p>示例 3:</p><p>输入: deadends = [“8887”,”8889”,”8878”,”8898”,”8788”,”8988”,”7888”,”9888”], target = “8888”<br>输出：-1<br>解释：<br>无法旋转到目标数字且不被锁定。</p><p>示例 4:</p><p>输入: deadends = [“0000”], target = “8888”<br>输出：-1</p><p>提示：</p><pre><code>死亡列表 deadends 的长度范围为 [1, 500]。目标数字 target 不会在 deadends 之中。每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 &apos;0000&apos; 到 &apos;9999&apos; 中产生。</code></pre><p>来源：力扣（LeetCode）752</p></blockquote><pre><code>class Solution {public:    int openLock(vector&lt;string&gt;&amp; deadends, string target) {        unordered_set&lt;string&gt; deadset(deadends.begin(),deadends.end());        if(deadset.find(&quot;0000&quot;)!&#x3D;deadset.end())            return -1;        unordered_set&lt;string&gt; visited;        deque&lt;string&gt; temp;        visited.insert(&quot;0000&quot;);        temp.push_back(&quot;0000&quot;);        int step&#x3D;0;        while(!temp.empty()){            int n&#x3D;temp.size();            for(int j&#x3D;0;j&lt;n;j++){                string s&#x3D;temp.front();                temp.pop_front();                if(s&#x3D;&#x3D;target)                    return step;                                for(int i&#x3D;0;i&lt;4;i++){                    string s1,s2;                    s1&#x3D;s;s2&#x3D;s;                    s1[i]&#x3D;(s1[i]&#x3D;&#x3D;&#39;0&#39;)?&#39;9&#39;:s1[i]-1;                    s2[i]&#x3D;(s2[i]&#x3D;&#x3D;&#39;9&#39;)?&#39;0&#39;:s2[i]+1;                    if(visited.find(s1)&#x3D;&#x3D;visited.end()&amp;&amp;deadset.find(s1)&#x3D;&#x3D;deadset.end()){                        temp.push_back(s1);                        visited.insert(s1);                    }                    if(visited.find(s2)&#x3D;&#x3D;visited.end()&amp;&amp;deadset.find(s2)&#x3D;&#x3D;deadset.end()){                        temp.push_back(s2);                        visited.insert(s2);                    }                }            }            step++;        }        return -1;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Breadth First Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复原IP地址</title>
    <link href="/2020/03/14/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <url>/2020/03/14/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h3 id="此题边界条件有很多细节"><a href="#此题边界条件有很多细节" class="headerlink" title="此题边界条件有很多细节"></a>此题边界条件有很多细节</h3><blockquote><p>IP地址的范围是0~255，这个0的存在就很emm<br>比如一个测试用例&gt;”010010”<br>0这里是不可以前置于一个整数前的!010，001这种是不允许的</p></blockquote><blockquote><p>标准回溯法：<br>    从一个起点开始，向可行的所有分支中尝试，并将可行的加入解集，如果发现不符合，立刻删除回到上一步重新选择。<br>    这里的pruning条件是当前的IP取完后，后面剩余的字符串长度是否可以支持后续的IP地址选取。<br>    depth代表你取了几个IP地址，例如depth=2，剩余字符串长度却有7，此时就发生了上溢，因此需要跳过这种情况，就有了<br>        s.length()-1-right&gt;3<em>(4-depth) 3为每一位IP最长的可能数字<br>    同理，下溢时，会有<br>        s.length()-1-right&lt;1</em>(4-depth)<br>    对于符合条件的子串，将它转为数字，判断是否合法(0-255)<br>    然后再接在结果串的末尾+”.”<br>    递归(深度搜索)，直到depth==4<br>    还有一点就是对前导0的判断，含有前导0的分支应立刻删去！</p></blockquote><pre><code>class Solution {public:    vector&lt;string&gt; restoreIpAddresses(string s) {        vector&lt;string&gt; res;        backtrack(0,1,res,s,&quot;&quot;);        return res;    }    void backtrack(int left,int depth,vector&lt;string&gt;&amp; res,string &amp;s,string temp){        if(left&gt;&#x3D;s.length())            return;        for(int right&#x3D;left;right&lt;s.length()&amp;&amp;right&lt;&#x3D;left+2;right++){            if(s.length()-right-1&gt;3*(4-depth))    continue;            if(s.length()-right-1&lt;1*(4-depth))    continue;            char t[4];            int i&#x3D;0;            for(;i&lt;&#x3D;right-left;i++){                t[i]&#x3D;s[left+i];            }            t[i]&#x3D;&#39;\0&#39;;            if(is_ip(t)){                if(depth&#x3D;&#x3D;4){                    temp+&#x3D;t;                    res.push_back(temp);                    return;                }                backtrack(right+1,depth+1,res,s,temp+t+&quot;.&quot;);            }        }    }    bool is_ip(const char s[]){        if(s[0]&#x3D;&#x3D;&#39;0&#39;&amp;&amp;s[1]!&#x3D;&#39;\0&#39;)            return false;        int a;        sscanf(s,&quot;%d&quot;,&amp;a);        if(a&gt;&#x3D;0&amp;&amp;a&lt;256)            return true;        else            return false;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Backtrack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CountCompleteTreeNodes</title>
    <link href="/2020/03/13/CountCompleteTreeNodes/"/>
    <url>/2020/03/13/CountCompleteTreeNodes/</url>
    
    <content type="html"><![CDATA[<pre><code>&#x2F;** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; *&#x2F;class Solution {public:    int countNodes(TreeNode* root) {        if(!root)            return 0;        int left&#x3D;level(root-&gt;left);        int right&#x3D;level(root-&gt;right);        if(left&#x3D;&#x3D;right){            return countNodes(root-&gt;right)+(1&lt;&lt;left);        }        else{            return countNodes(root-&gt;left)+(1&lt;&lt;right);        }    }    int level(TreeNode* root){        int level&#x3D;0;        while(root){            root&#x3D;root-&gt;left;            level++;        }        return level;    }};</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreePaths</title>
    <link href="/2020/03/13/BinaryTreePaths/"/>
    <url>/2020/03/13/BinaryTreePaths/</url>
    
    <content type="html"><![CDATA[<pre><code>&#x2F;** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; *&#x2F;class Solution {public:    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {        if(!root)            return {};        vector&lt;string&gt; res;        Path(root,res,&quot;&quot;);        return res;      }    void Path(TreeNode* root,vector&lt;string&gt;&amp; res,string path){        path+&#x3D;to_string(root-&gt;val);        if(!root-&gt;left&amp;&amp;!root-&gt;right){            res.push_back(path);            return;        }              if(root-&gt;left)            Path(root-&gt;left,res,path+&quot;-&gt;&quot;);        if(root-&gt;right)            Path(root-&gt;right,res,path+&quot;-&gt;&quot;);    }};</code></pre><p>不递归这就绝对不是简单的问题了(说到底还是自己太vegetable)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MajorityElement</title>
    <link href="/2020/03/13/MajorityElement/"/>
    <url>/2020/03/13/MajorityElement/</url>
    
    <content type="html"><![CDATA[<pre><code>class Solution {public:    int majorityElement(vector&lt;int&gt;&amp; nums) {        int n&#x3D;nums.size();        int count&#x3D;0;        int temp&#x3D;0;        for(int i&#x3D;0;i&lt;n;i++){            if(count&#x3D;&#x3D;0){                temp&#x3D;nums[i];                count++;            }            else{                nums[i]&#x3D;&#x3D;temp?count++:count--;            }        }        return temp;    }};</code></pre><pre><code>class Solution {public:    int majorityElement(vector&lt;int&gt;&amp; nums) {        int n&#x3D;nums.size();        int res&#x3D;0;        for(int i&#x3D;0;i&lt;32;i++){            int one&#x3D;0,zero&#x3D;0;            for(int j&#x3D;0;j&lt;n;j++){                if(one&gt;n&#x2F;2||zero&gt;n&#x2F;2)   break;                if((nums[j]&amp;(1&lt;&lt;i))!&#x3D;0)   one++;                else   zero++;               }            if(one&gt;zero)                res&#x3D;res|(1&lt;&lt;i);        }        return res;    }};</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Reverse Nodes in k-Group</title>
    <link href="/2020/03/12/LC-25/"/>
    <url>/2020/03/12/LC-25/</url>
    
    <content type="html"><![CDATA[<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>Example:</p><p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>Note:</p><pre><code>Only constant extra memory is allowed.You may not alter the values in the list&#39;s nodes, only nodes itself may be changed.</code></pre><pre><code>&#x2F;** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; *&#x2F;class Solution {public:    ListNode* reverseKGroup(ListNode* head, int k) {        ListNode* dummy&#x3D;new ListNode(0);        ListNode* prev&#x3D;dummy;        dummy-&gt;next&#x3D;head;        ListNode* curr&#x3D;head;        ListNode* temp;        int len&#x3D;0;        while(head){            len++;            head&#x3D;head-&gt;next;        }        head&#x3D;dummy-&gt;next;        for(int i&#x3D;0;i&lt;len&#x2F;k;i++){            for(int j&#x3D;0;j&lt;k-1;j++){                temp&#x3D;curr-&gt;next;                curr-&gt;next&#x3D;temp-&gt;next;                temp-&gt;next&#x3D;prev-&gt;next;                prev-&gt;next&#x3D;temp;            }            prev&#x3D;curr;            curr&#x3D;prev-&gt;next;        }        return dummy-&gt;next;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linked List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode1071</title>
    <link href="/2020/03/12/LeetCode1071/"/>
    <url>/2020/03/12/LeetCode1071/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/12/LeetCode1071/t.png" srcset="/img/loading.gif" alt="1071"></p><blockquote><p>greatest common divisor<br>最大公因数与辗转相除法<br>    gcd(a,b)=gcd(b,a%b)<br>证明：设a=kb+r, r=a%b<br>    设d=gcd(a,b), d|a,d|b;<br>    r=a-kb; r/d=a/d-k*b/d;<br>    所以r/d也是一个整数，d|r<br>    所以gcd(a,b)=gcd(b.a%b).<br>    同样的，对于一个字符串的长度而言，可以先找到它们的公因数长度的子串，如果存在这样一个子串，那么它的长度必然等于原字符串中的任一个最小因子长度的子字符串。<br>    注意每次都要先进行条件判断，即它们是否同构</p></blockquote><pre><code>class Solution {public:    inline int gcd(int a,int b){return b&#x3D;&#x3D;0?a:gcd(b,a%b);}    string gcdOfStrings(string str1, string str2) {        if(str1+str2!&#x3D;str2+str1)    return&quot;&quot;;        return str1.substr(0,gcd(str1.size(),str2.size()));    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Combination</title>
    <link href="/2020/03/11/Combination/"/>
    <url>/2020/03/11/Combination/</url>
    
    <content type="html"><![CDATA[<h3 id="215-Combination-Sum-III"><a href="#215-Combination-Sum-III" class="headerlink" title="215.Combination Sum III"></a>215.Combination Sum III</h3><p>先上代码233：</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {        vector&lt;vector&lt;int&gt;&gt; res;        vector&lt;int&gt; path;        backtrack(n,path,k,res,0);        return res;    }    void backtrack(int n,vector&lt;int&gt;&amp; path,int k,vector&lt;vector&lt;int&gt;&gt;&amp; res,int start){        if(n&lt;0)            return;        if(k&#x3D;&#x3D;0){            if(n&#x3D;&#x3D;0)                res.push_back(path);            return;        }        for(int i&#x3D;start;i&lt;9;i++){            path.push_back(i+1);            backtrack(n-(i+1),path,k-1,res,i+1);            path.pop_back();        }    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Backtrack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>findKth</title>
    <link href="/2020/03/11/findKth/"/>
    <url>/2020/03/11/findKth/</url>
    
    <content type="html"><![CDATA[<h3 id="215-寻找第K大的元素"><a href="#215-寻找第K大的元素" class="headerlink" title="215.寻找第K大的元素"></a>215.寻找第K大的元素</h3><p><img src="/2020/03/11/findKth/find.png" srcset="/img/loading.gif" alt="txt"></p><pre><code>class Solution {public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {        int n&#x3D;nums.size();        return findKth(nums,0,n-1,k);    }    int findKth(vector&lt;int&gt; &amp;nums,int left,int right,int k){        int index&#x3D;partition(nums,left,right);        if(index+1&#x3D;&#x3D;k)            return nums[index];        else if(index+1&lt;k)            return findKth(nums,index+1,right,k);        else if(index+1&gt;k)            return findKth(nums,left,index-1,k);        else            return -1;    }    int partition(vector&lt;int&gt;&amp; nums,int left,int right){        int pivot&#x3D;rand()%(right-left+1)+left;        swap(nums[left],nums[pivot]);        int temp&#x3D;nums[left];        int i&#x3D;left;        int j&#x3D;left+1;        while(j&lt;&#x3D;right){            if(nums[j]&gt;&#x3D;temp)                swap(nums[j],nums[++i]);            j++;        }        swap(nums[left],nums[i]);        return i;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
      <tag>Sorting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-207</title>
    <link href="/2020/03/10/LeetCode-207/"/>
    <url>/2020/03/10/LeetCode-207/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/10/LeetCode-207/LeetCode-207%5Ctest.png" srcset="/img/loading.gif" alt="207"></p><h3 id="如何理解这样一个问题"><a href="#如何理解这样一个问题" class="headerlink" title="如何理解这样一个问题"></a>如何理解这样一个问题</h3><blockquote><p>课程1是课程0的前期必修课程，所以存在1-&gt;0这样的一种映射关系<br>那么根据课程表里的信息，我们可以相应的建立这样一张课程图。<br>图中每一个顶点可能没有入度(因为没有前期必修的课程基础)，<br>这样的一系列节点自然符合课程的修读要求，是自然符合的。那么，我们只需要关系那些存在入度的顶点，观察它们再现有的条件下，是否能够满足，如果全部都满足了，那么就是有效的课程，反之则无效。</p></blockquote><h3 id="第一种策略：广度优先搜索"><a href="#第一种策略：广度优先搜索" class="headerlink" title="第一种策略：广度优先搜索"></a>第一种策略：广度优先搜索</h3><pre><code>class Solution {public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {        map&lt;int,set&lt;int&gt;&gt; adjacent;        vector&lt;int&gt; indegree(numCourses);        for(auto&amp; p:prerequisites){            adjacent[p[1]].insert(p[0]);            indegree[p[0]]++;        }        queue&lt;int&gt; todo;        for(int i&#x3D;0;i&lt;numCourses;i++){            if(!indegree[i])                todo.push(i);&#x2F;&#x2F;        }        int count&#x3D;0;        while(!todo.empty()){            auto vertex&#x3D;todo.front();            todo.pop();            auto t&#x3D;adjacent[vertex];            for(auto x:t){                --indegree[x];                if(!indegree[x])                        todo.push(x);            }            count++;        }        return count&#x3D;&#x3D;numCourses;    }};</code></pre><blockquote><p>每一次操作时，先扣除与目前访问顶点相连的邻居们的入度，然后对于每一个入度为0的顶点的所有邻居进行遍历并将它们入队，完成一次操作，将完成的课程数count++，最后再与课程总数进行比较。</p></blockquote><h3 id="第二种策略-深度优先搜索"><a href="#第二种策略-深度优先搜索" class="headerlink" title="第二种策略: 深度优先搜索"></a>第二种策略: 深度优先搜索</h3><pre><code>class Solution {public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {        map&lt;int,set&lt;int&gt;&gt; adjacent;        vector&lt;int&gt; outdegree(numCourses);        for(auto&amp; p:prerequisites){            adjacent[p[0]].insert(p[1]);            outdegree[p[1]]++;        }        stack&lt;int&gt; todo;        for(int i&#x3D;0;i&lt;numCourses;i++){            if(!outdegree[i])                todo.push(i);&#x2F;&#x2F;        }        int count&#x3D;0;        while(!todo.empty()){            auto vertex&#x3D;todo.top();            todo.pop();            auto t&#x3D;adjacent[vertex];            for(auto x:t){                --outdegree[x];                if(!outdegree[x])                        todo.push(x);            }            count++;        }        return count&#x3D;&#x3D;numCourses;    }};</code></pre><blockquote><p>与第一种方法正好相反，我们对顶点的出度进行讨论。顶点出度为0的那些，作为深度优先搜索，应该是最后达到但是最先完成访问的那些末端，我们假设访问到了这样一个顶点，代表了我们修读完了一门课程，接下来我们去寻找能够访问到这个顶点的前驱们，注意先要将这些前驱们的出度进行修改。如果发现前驱们的出度也变为0，则我们就找到了这样一种前后对应关系的课程，反复操作直至栈空。注意如果存在环形结构，它们顶点的出度必然不为0，同时也不可能在合法访问后发生减小，因此它们根本无法被访问到，count不可能到达原定的课程数，也就不满足条件。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Graph</tag>
      
      <tag>Breadth First Search</tag>
      
      <tag>Depth First Search</tag>
      
      <tag>Topological Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-84</title>
    <link href="/2020/03/10/LeetCode-84/"/>
    <url>/2020/03/10/LeetCode-84/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/10/LeetCode-84/aaa.jpg" srcset="/img/loading.gif" alt="aaa"></p><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        int n&#x3D;heights.size();        int m&#x3D;0;        for(int i&#x3D;0;i&lt;n;i++){            int k&#x3D;INT_MAX;            for(int j&#x3D;i;j&lt;n;j++){                k&#x3D;min(k,heights[j]);                m&#x3D;max(m,(j-i+1)*k);            }        }        return m;    }};</code></pre><pre><code>class Solution {public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        int n&#x3D;heights.size();        int m&#x3D;0;        vector&lt;int&gt; leftMin(n,-1);        vector&lt;int&gt; rightMin(n,n);        for(int i&#x3D;1;i&lt;n;i++){            int j&#x3D;i-1;            while(j&gt;&#x3D;0&amp;&amp;heights[j]&gt;&#x3D;heights[i]){                j&#x3D;leftMin[j];            }            leftMin[i]&#x3D;j;        }        for(int i&#x3D;n-2;i&gt;&#x3D;0;i--){            int j&#x3D;i+1;            while(j&lt;n&amp;&amp;heights[j]&gt;&#x3D;heights[i]){                j&#x3D;rightMin[j];            }            rightMin[i]&#x3D;j;        }        for(int i&#x3D;0;i&lt;n;i++){            m&#x3D;max(m,heights[i]*(rightMin[i]-leftMin[i]-1));        }        return m;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-18</title>
    <link href="/2020/03/10/LeetCode-18/"/>
    <url>/2020/03/10/LeetCode-18/</url>
    
    <content type="html"><![CDATA[<p>LeetCode N数之和问题-ver 3.0</p><p>  四数之和问题：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>  注意：答案中不可以包含重复的四元组。</p><p>一点问题：如何避免重复的数字反复的加入结果集合？<br>最直接的想法是先暴力枚举出所有的可能组合，再用set去重，时间复杂度O(N^4)-&gt;O(N^3)<br>使用target-nums[i]改进循环，时间复杂度可下降至O(N^3)<br>如何去重？注意两个内部的while循环，两个if语句</p><pre><code>if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])</code></pre> <ol><li>不能颠倒两个条件的顺序</li><li>从i=1开始才有可能执行该语句，从而跳过前面的k-&gt;i中的重复元素</li></ol><pre><code>while(k&lt;l&amp;&amp;nums[k]&#x3D;&#x3D;nums[k+1])  ++k;while(k&lt;l&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1])  --l;++k;--l;&#x2F;&#x2F;注意这里，判断的边界需要再加1&#x2F;减1</code></pre><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="以下是一种解法："><a href="#以下是一种解法：" class="headerlink" title="以下是一种解法："></a>以下是一种解法：</h3><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;vector&lt;int&gt;&gt; res;        if(nums.empty())            return {};                sort(nums.begin(),nums.end());        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;i++){            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])  {                continue;                            }              int threeSum&#x3D;target-nums[i];            for(int j&#x3D;i+1;j&lt;n;j++){                if(j&gt;i+1&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]){                    continue;                                    }                    int twoSum&#x3D;threeSum-nums[j];                int k&#x3D;j+1;                int l&#x3D;n-1;                while(k&lt;l){                    if(nums[k]+nums[l]&#x3D;&#x3D;twoSum){                        res.push_back({nums[i],nums[j],nums[k],nums[l]});                        while(k&lt;l&amp;&amp;nums[k]&#x3D;&#x3D;nums[k+1]){                            ++k;                        }                        while(k&lt;l&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1]){                            --l;                        }                        ++k;--l;                      }                    else if(nums[k]+nums[l]&gt;twoSum){                        --l;                                            }                    else{                        ++k;                                            }                    }            }        }        return res;    }};</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Two pointers</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B-Tree dynamtic procedures/remove&amp;insert</title>
    <link href="/2020/03/09/B-Tree/"/>
    <url>/2020/03/09/B-Tree/</url>
    
    <content type="html"><![CDATA[<blockquote><p>B-树的操作：插入与删除</p></blockquote><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>首先，用查找算法找到关键码对应节点及其直接后继，类似于执行BST的删除操作，然后交换当前节点与直接后继，并将交换后的直接后继处的叶子节点删除。</p><pre><code>template&lt;typename T&gt; bool BTree&lt;T&gt;::remove(T const&amp; e){    BTNode&lt;T&gt;* v&#x3D;search(e);    if(!v)  return false;    Rank r&#x3D;v-&gt;key.search(e);    if(v-&gt;child[0]){&#x2F;&#x2F;如果v不是叶子节点，必然存在直接后继        BTNode&lt;T&gt;* u&#x3D;v-&gt;child[r+1];        while(u-&gt;child[0])  u&#x3D;u-&gt;child[0];        v-&gt;key[r]&#x3D;u-&gt;key[0];        v-&gt;key.remove(r);        v-&gt;child.remove(r+1);        _size--;    }    solveUnderFlow(v);&#x2F;&#x2F;处理由于删除发生的下溢问题    return true;       }</code></pre><h3 id="下溢问题"><a href="#下溢问题" class="headerlink" title="下溢问题"></a>下溢问题</h3><p>三种可能：左侧足够多，右侧足够多，左右都即将下溢</p><pre><code>template&lt;typename T&gt; void BTree&lt;T&gt;::solveUnderFlow(BTNode&lt;T&gt;* v){    if((_order+1)&#x2F;2&lt;&#x3D;v-&gt;child-&gt;size())&#x2F;&#x2F;没有发生下溢，不需要变化        return;    BTNode&lt;T&gt;* p&#x3D;v-&gt;parent;    if(!p){        if(!v-&gt;key.size()&amp;&amp;v-&gt;child[0]){            _root&#x3D;v-&gt;child[0];            _root-&gt;parent&#x3D;NULL;            v-&gt;child[0]&#x3D;NULL;            release(v);        }&#x2F;&#x2F;树根v没有关键码，却有唯一的非空孩子        &#x2F;&#x2F;则可以销毁掉这个节点，并将整树高度下降一个单位               return;    }    Rank r&#x3D;0;    while(p-&gt;child[r]!&#x3D;v)   r++;    &#x2F;&#x2F;确定v是p的第r个孩子，此时由于v可能不含关键码    &#x2F;&#x2F;所以不能直接通过关键码查找v    &#x2F;&#x2F;情况1：向左兄弟借关键码    if(r&gt;0){&#x2F;&#x2F;v不是p的第一个孩子        BTNode&lt;T&gt;* ls&#x3D;p-&gt;child[r-1];&#x2F;&#x2F;想想中序遍历的直接后继        if((_order+1)&#x2F;2&lt;ls-&gt;child.size()){&#x2F;&#x2F;左兄弟够借            v-&gt;key.insert(0,p-&gt;key[r-1]);&#x2F;&#x2F;先从父亲借1个            p-&gt;key[r-1]&#x3D;ls-&gt;key.remove(ls-&gt;key.size()-1);&#x2F;&#x2F;左兄弟移给父亲            v-&gt;child.insert(0,ls-&gt;child.remove(ls-&gt;child.size()-1));&#x2F;&#x2F;引用节点也要相应的转移给右边的兄弟        }        if(v-&gt;child[0]) v-&gt;child[0]-&gt;parent&#x3D;v;        &#x2F;&#x2F;移完了记得更新parent引用        return;    }    &#x2F;&#x2F;至此，左兄弟要么为空，要么不够借    &#x2F;&#x2F;情况2：向右兄弟借关键码    if(r&lt;p-&gt;child.size()){        BTNode&lt;T&gt;* rs&#x3D;p-&gt;child[r+1];        if((_order+1)&#x2F;2&lt;rs-&gt;child.size()){            v-&gt;key.insert(v-&gt;key.size(),p-&gt;key[r]);&#x2F;&#x2F;从父亲借一个，插入左边最右侧            p-&gt;key[r]&#x3D;rs-&gt;key.remove(0);            v-&gt;child.insert(v-&gt;child.size(),rs-&gt;child.remove(0));        }        if(v-&gt;child[v-&gt;child.size()-1])            v-&gt;child[v-&gt;child.size()-1]-&gt;parent&#x3D;v;       }    &#x2F;&#x2F;至此，右兄弟要么为空，要么不够借    &#x2F;&#x2F;情况3，左右兄弟要么其一为空，要么都不够借    if(r&gt;0){&#x2F;&#x2F;向左兄弟合并        BTNode&lt;T&gt;* ls&#x3D;p-&gt;child[r-1];        ls-&gt;key.insert(ls-&gt;key.size(),p-&gt;key.remove(r-1));        p-&gt;child.remove(r);&#x2F;&#x2F;将p的第r-1个关键码转入ls        ls-&gt;child.insert(ls-&gt;child.size(),v-&gt;child.remove(0));        if(ls-&gt;child[ls-&gt;child.size()-1])            ls-&gt;child[ls-&gt;child.size()-1]-&gt;parent&#x3D;ls;        while(!v-&gt;key.empty()){            ls-&gt;key.insert(ls-&gt;key.size(),v-&gt;key.remove(0));            ls-&gt;child.insert(ls-&gt;child.size(),v-&gt;child.remove(0));            if(ls-&gt;child[ls-&gt;child.size()-1])                ls-&gt;child[ls-&gt;child.size()-1]-&gt;parent&#x3D;ls;        }        release(v);    }    else{&#x2F;&#x2F;向右兄弟合并        BTNode&lt;T&gt;* rs&#x3D;p-&gt;child[r+1];        rs-&gt;key.insert(0,p-&gt;key.remove(r));        p-&gt;child.remove(r);        rs-&gt;child.insert(0,v-&gt;child.remove(v-&gt;child.size()-1));        if(rs-&gt;child[0])            rs-&gt;child[0]-&gt;parent&#x3D;rs;        while(!v-&gt;key.empty()){            rs-&gt;key.insert(0,v-&gt;key.remove(v-&gt;key.size()-1));            rs-&gt;child.insert(0,v-&gt;key.remove(v-child.size()-1));            if(rs-&gt;child[0])                rs-&gt;child[0]-&gt;parent&#x3D;rs;        }        release(v);    }    solveUnderFlow(p);    return;}</code></pre><p>复杂度：平均只有常数次的操作。极端情况为O(logn)的时间复杂度。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/03/09/hello-world/"/>
    <url>/2020/03/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello!"></a>Hello!</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
